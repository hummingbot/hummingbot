{"version":3,"file":"index.cjs.js","sources":["../../../packages/merge/dist/index.esm.js","../../../dist/loaders/graphql-file/src/index.js"],"sourcesContent":["import { mergeDeep, compareNodes, isNotEqual, printSchemaWithDirectives, createSchemaDefinition, asArray, getResolversFromSchema, SchemaDirectiveVisitor } from '@graphql-tools/utils';\nimport { getDescription, visit, print, Source, Kind, isSchema, parse, isScalarType, isSpecifiedScalarType, isIntrospectionType, isObjectType, isInterfaceType, isInputObjectType, isUnionType, isEnumType, buildSchema, buildASTSchema } from 'graphql';\nimport { addResolversToSchema, addErrorLoggingToSchema } from '@graphql-tools/schema';\n\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\nfunction mergeResolvers(resolversDefinitions, options) {\n    if (!resolversDefinitions || resolversDefinitions.length === 0) {\n        return {};\n    }\n    if (resolversDefinitions.length === 1) {\n        const singleDefinition = resolversDefinitions[0];\n        if (Array.isArray(singleDefinition)) {\n            return mergeResolvers(singleDefinition);\n        }\n        return singleDefinition;\n    }\n    const resolversFactories = new Array();\n    const resolvers = new Array();\n    for (let resolversDefinition of resolversDefinitions) {\n        if (Array.isArray(resolversDefinition)) {\n            resolversDefinition = mergeResolvers(resolversDefinition);\n        }\n        if (typeof resolversDefinition === 'function') {\n            resolversFactories.push(resolversDefinition);\n        }\n        else if (typeof resolversDefinition === 'object') {\n            resolvers.push(resolversDefinition);\n        }\n    }\n    let result = {};\n    if (resolversFactories.length) {\n        result = ((...args) => {\n            const resultsOfFactories = resolversFactories.map(factory => factory(...args));\n            return resolvers.concat(resultsOfFactories).reduce(mergeDeep, {});\n        });\n    }\n    else {\n        result = resolvers.reduce(mergeDeep, {});\n    }\n    if (options && options.exclusions) {\n        for (const exclusion of options.exclusions) {\n            const [typeName, fieldName] = exclusion.split('.');\n            if (!fieldName || fieldName === '*') {\n                delete result[typeName];\n            }\n            else if (result[typeName]) {\n                delete result[typeName][fieldName];\n            }\n        }\n    }\n    return result;\n}\n\nfunction mergeArguments(args1, args2, config) {\n    const result = deduplicateArguments([].concat(args2, args1).filter(a => a));\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\nfunction deduplicateArguments(args) {\n    return args.reduce((acc, current) => {\n        const dup = acc.find(arg => arg.name.value === current.name.value);\n        if (!dup) {\n            return acc.concat([current]);\n        }\n        return acc;\n    }, []);\n}\n\nlet commentsRegistry = {};\nfunction resetComments() {\n    commentsRegistry = {};\n}\nfunction collectComment(node) {\n    const entityName = node.name.value;\n    pushComment(node, entityName);\n    switch (node.kind) {\n        case 'EnumTypeDefinition':\n            node.values.forEach(value => {\n                pushComment(value, entityName, value.name.value);\n            });\n            break;\n        case 'ObjectTypeDefinition':\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n            if (node.fields) {\n                node.fields.forEach((field) => {\n                    pushComment(field, entityName, field.name.value);\n                    if (isFieldDefinitionNode(field) && field.arguments) {\n                        field.arguments.forEach(arg => {\n                            pushComment(arg, entityName, field.name.value, arg.name.value);\n                        });\n                    }\n                });\n            }\n            break;\n    }\n}\nfunction pushComment(node, entity, field, argument) {\n    const comment = getDescription(node, { commentDescriptions: true });\n    if (typeof comment !== 'string' || comment.length === 0) {\n        return;\n    }\n    const keys = [entity];\n    if (field) {\n        keys.push(field);\n        if (argument) {\n            keys.push(argument);\n        }\n    }\n    const path = keys.join('.');\n    if (!commentsRegistry[path]) {\n        commentsRegistry[path] = [];\n    }\n    commentsRegistry[path].push(comment);\n}\nfunction printComment(comment) {\n    return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n// import { visit, VisitFn } from 'graphql/language/visitor';\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n    return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction addDescription(cb) {\n    return (node, _key, _parent, path, ancestors) => {\n        const keys = [];\n        const parent = path.reduce((prev, key) => {\n            if (['fields', 'arguments', 'values'].includes(key)) {\n                keys.push(prev.name.value);\n            }\n            return prev[key];\n        }, ancestors[0]);\n        const key = [...keys, parent.name.value].join('.');\n        const items = [];\n        if (commentsRegistry[key]) {\n            items.push(...commentsRegistry[key]);\n        }\n        return join([...items.map(printComment), node.description, cb(node)], '\\n');\n    };\n}\nfunction indent(maybeString) {\n    return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n    return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n    return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription) {\n    const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n    return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1\n        ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"`\n        : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction printWithComments(ast) {\n    return visit(ast, {\n        leave: {\n            Name: node => node.value,\n            Variable: node => `$${node.name}`,\n            // Document\n            Document: node => `${node.definitions\n                .map(defNode => `${defNode}\\n${defNode[0] === '#' ? '' : '\\n'}`)\n                .join('')\n                .trim()}\\n`,\n            OperationTypeDefinition: node => `${node.operation}: ${node.type}`,\n            VariableDefinition: ({ variable, type, defaultValue }) => `${variable}: ${type}${wrap(' = ', defaultValue)}`,\n            SelectionSet: ({ selections }) => block(selections),\n            Field: ({ alias, name, arguments: args, directives, selectionSet }) => join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], '  '),\n            Argument: addDescription(({ name, value }) => `${name}: ${value}`),\n            // Value\n            IntValue: ({ value }) => value,\n            FloatValue: ({ value }) => value,\n            StringValue: ({ value, block: isBlockString }, key) => isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value),\n            BooleanValue: ({ value }) => (value ? 'true' : 'false'),\n            NullValue: () => 'null',\n            EnumValue: ({ value }) => value,\n            ListValue: ({ values }) => `[${join(values, ', ')}]`,\n            ObjectValue: ({ fields }) => `{${join(fields, ', ')}}`,\n            ObjectField: ({ name, value }) => `${name}: ${value}`,\n            // Directive\n            Directive: ({ name, arguments: args }) => `@${name}${wrap('(', join(args, ', '), ')')}`,\n            // Type\n            NamedType: ({ name }) => name,\n            ListType: ({ type }) => `[${type}]`,\n            NonNullType: ({ type }) => `${type}!`,\n            // Type System Definitions\n            SchemaDefinition: ({ directives, operationTypes }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n            ScalarTypeDefinition: addDescription(({ name, directives }) => join(['scalar', name, join(directives, ' ')], ' ')),\n            ObjectTypeDefinition: addDescription(({ name, interfaces, directives, fields }) => join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ')),\n            FieldDefinition: addDescription(({ name, arguments: args, type, directives }) => `${name + wrap('(', join(args, ', '), ')')}: ${type}${wrap(' ', join(directives, ' '))}`),\n            InputValueDefinition: addDescription(({ name, type, defaultValue, directives }) => join([`${name}: ${type}`, wrap('= ', defaultValue), join(directives, ' ')], ' ')),\n            InterfaceTypeDefinition: addDescription(({ name, directives, fields }) => join(['interface', name, join(directives, ' '), block(fields)], ' ')),\n            UnionTypeDefinition: addDescription(({ name, directives, types }) => join(['union', name, join(directives, ' '), types && types.length !== 0 ? `= ${join(types, ' | ')}` : ''], ' ')),\n            EnumTypeDefinition: addDescription(({ name, directives, values }) => join(['enum', name, join(directives, ' '), block(values)], ' ')),\n            EnumValueDefinition: addDescription(({ name, directives }) => join([name, join(directives, ' ')], ' ')),\n            InputObjectTypeDefinition: addDescription(({ name, directives, fields }) => join(['input', name, join(directives, ' '), block(fields)], ' ')),\n            ScalarTypeExtension: ({ name, directives }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n            ObjectTypeExtension: ({ name, interfaces, directives, fields }) => join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n            InterfaceTypeExtension: ({ name, directives, fields }) => join(['extend interface', name, join(directives, ' '), block(fields)], ' '),\n            UnionTypeExtension: ({ name, directives, types }) => join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? `= ${join(types, ' | ')}` : ''], ' '),\n            EnumTypeExtension: ({ name, directives, values }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n            InputObjectTypeExtension: ({ name, directives, fields }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n            DirectiveDefinition: addDescription(({ name, arguments: args, locations }) => `directive @${name}${wrap('(', join(args, ', '), ')')} on ${join(locations, ' | ')}`),\n        },\n    });\n}\nfunction isFieldDefinitionNode(node) {\n    return node.kind === 'FieldDefinition';\n}\n\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n    return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction nameAlreadyExists(name, namesArr) {\n    return namesArr.some(({ value }) => value === name.value);\n}\nfunction mergeArguments$1(a1, a2) {\n    const result = [...a2];\n    for (const argument of a1) {\n        const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n        if (existingIndex > -1) {\n            const existingArg = result[existingIndex];\n            if (existingArg.value.kind === 'ListValue') {\n                const source = existingArg.value.values;\n                const target = argument.value.values;\n                // merge values of two lists\n                existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n                    const value = targetVal.value;\n                    return !value || !source.some((sourceVal) => sourceVal.value === value);\n                });\n            }\n            else {\n                existingArg.value = argument.value;\n            }\n        }\n        else {\n            result.push(argument);\n        }\n    }\n    return result;\n}\nfunction deduplicateDirectives(directives) {\n    return directives\n        .map((directive, i, all) => {\n        const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n        if (firstAt !== i) {\n            const dup = all[firstAt];\n            directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);\n            return null;\n        }\n        return directive;\n    })\n        .filter(d => d);\n}\nfunction mergeDirectives(d1 = [], d2 = [], config) {\n    const reverseOrder = config && config.reverseDirectives;\n    const asNext = reverseOrder ? d1 : d2;\n    const asFirst = reverseOrder ? d2 : d1;\n    const result = deduplicateDirectives([...asNext]);\n    for (const directive of asFirst) {\n        if (directiveAlreadyExists(result, directive)) {\n            const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n            const existingDirective = result[existingDirectiveIndex];\n            result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);\n        }\n        else {\n            result.push(directive);\n        }\n    }\n    return result;\n}\nfunction validateInputs(node, existingNode) {\n    const printedNode = print(node);\n    const printedExistingNode = print(existingNode);\n    const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n    const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n    if (!sameArguments) {\n        throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n    }\n}\nfunction mergeDirective(node, existingNode) {\n    if (existingNode) {\n        validateInputs(node, existingNode);\n        return {\n            ...node,\n            locations: [\n                ...existingNode.locations,\n                ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations)),\n            ],\n        };\n    }\n    return node;\n}\nfunction deduplicateLists(source, target, filterFn) {\n    return source.concat(target.filter(val => filterFn(val, source)));\n}\n\nfunction mergeEnumValues(first, second, config) {\n    const enumValueMap = new Map();\n    for (const firstValue of first) {\n        enumValueMap.set(firstValue.name.value, firstValue);\n    }\n    for (const secondValue of second) {\n        const enumValue = secondValue.name.value;\n        if (enumValueMap.has(enumValue)) {\n            const firstValue = enumValueMap.get(enumValue);\n            firstValue.description = secondValue.description || firstValue.description;\n            firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);\n        }\n        else {\n            enumValueMap.set(enumValue, secondValue);\n        }\n    }\n    const result = [...enumValueMap.values()];\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\n\nfunction mergeEnum(e1, e2, config) {\n    if (e2) {\n        return {\n            name: e1.name,\n            description: e1['description'] || e2['description'],\n            kind: (config && config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition'\n                ? 'EnumTypeDefinition'\n                : 'EnumTypeExtension',\n            loc: e1.loc,\n            directives: mergeDirectives(e1.directives, e2.directives, config),\n            values: mergeEnumValues(e1.values, e2.values, config),\n        };\n    }\n    return config && config.convertExtensions\n        ? {\n            ...e1,\n            kind: 'EnumTypeDefinition',\n        }\n        : e1;\n}\n\nfunction isStringTypes(types) {\n    return typeof types === 'string';\n}\nfunction isSourceTypes(types) {\n    return types instanceof Source;\n}\nfunction isGraphQLType(definition) {\n    return definition.kind === 'ObjectTypeDefinition';\n}\nfunction isGraphQLTypeExtension(definition) {\n    return definition.kind === 'ObjectTypeExtension';\n}\nfunction isGraphQLEnum(definition) {\n    return definition.kind === 'EnumTypeDefinition';\n}\nfunction isGraphQLEnumExtension(definition) {\n    return definition.kind === 'EnumTypeExtension';\n}\nfunction isGraphQLUnion(definition) {\n    return definition.kind === 'UnionTypeDefinition';\n}\nfunction isGraphQLUnionExtension(definition) {\n    return definition.kind === 'UnionTypeExtension';\n}\nfunction isGraphQLScalar(definition) {\n    return definition.kind === 'ScalarTypeDefinition';\n}\nfunction isGraphQLScalarExtension(definition) {\n    return definition.kind === 'ScalarTypeExtension';\n}\nfunction isGraphQLInputType(definition) {\n    return definition.kind === 'InputObjectTypeDefinition';\n}\nfunction isGraphQLInputTypeExtension(definition) {\n    return definition.kind === 'InputObjectTypeExtension';\n}\nfunction isGraphQLInterface(definition) {\n    return definition.kind === 'InterfaceTypeDefinition';\n}\nfunction isGraphQLInterfaceExtension(definition) {\n    return definition.kind === 'InterfaceTypeExtension';\n}\nfunction isGraphQLDirective(definition) {\n    return definition.kind === 'DirectiveDefinition';\n}\nfunction extractType(type) {\n    let visitedType = type;\n    while (visitedType.kind === 'ListType' || visitedType.kind === 'NonNullType') {\n        visitedType = visitedType.type;\n    }\n    return visitedType;\n}\nfunction isSchemaDefinition(node) {\n    return node.kind === 'SchemaDefinition';\n}\nfunction isWrappingTypeNode(type) {\n    return type.kind !== Kind.NAMED_TYPE;\n}\nfunction isListTypeNode(type) {\n    return type.kind === Kind.LIST_TYPE;\n}\nfunction isNonNullTypeNode(type) {\n    return type.kind === Kind.NON_NULL_TYPE;\n}\nfunction printTypeNode(type) {\n    if (isListTypeNode(type)) {\n        return `[${printTypeNode(type.type)}]`;\n    }\n    if (isNonNullTypeNode(type)) {\n        return `${printTypeNode(type.type)}!`;\n    }\n    return type.name.value;\n}\n\nfunction fieldAlreadyExists(fieldsArr, otherField) {\n    const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n    if (result) {\n        const t1 = extractType(result.type);\n        const t2 = extractType(otherField.type);\n        if (t1.name.value !== t2.name.value) {\n            throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n        }\n    }\n    return !!result;\n}\nfunction mergeFields(type, f1, f2, config) {\n    const result = [...f2];\n    for (const field of f1) {\n        if (fieldAlreadyExists(result, field)) {\n            const existing = result.find((f) => f.name.value === field.name.value);\n            if (config && config.throwOnConflict) {\n                preventConflicts(type, existing, field, false);\n            }\n            else {\n                preventConflicts(type, existing, field, true);\n            }\n            if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {\n                existing.type = field.type;\n            }\n            existing.arguments = mergeArguments(field['arguments'] || [], existing.arguments || [], config);\n            existing.directives = mergeDirectives(field.directives, existing.directives, config);\n            existing.description = field.description || existing.description;\n        }\n        else {\n            result.push(field);\n        }\n    }\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    if (config && config.exclusions) {\n        return result.filter(field => !config.exclusions.includes(`${type.name.value}.${field.name.value}`));\n    }\n    return result;\n}\nfunction preventConflicts(type, a, b, ignoreNullability = false) {\n    const aType = printTypeNode(a.type);\n    const bType = printTypeNode(b.type);\n    if (isNotEqual(aType, bType)) {\n        if (safeChangeForFieldType(a.type, b.type, ignoreNullability) === false) {\n            throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n        }\n    }\n}\nfunction safeChangeForFieldType(oldType, newType, ignoreNullability = false) {\n    // both are named\n    if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n        return oldType.toString() === newType.toString();\n    }\n    // new is non-null\n    if (isNonNullTypeNode(newType)) {\n        const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n        return safeChangeForFieldType(ofType, newType.type);\n    }\n    // old is non-null\n    if (isNonNullTypeNode(oldType)) {\n        return safeChangeForFieldType(newType, oldType, ignoreNullability);\n    }\n    // old is list\n    if (isListTypeNode(oldType)) {\n        return ((isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type)) ||\n            (isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type'])));\n    }\n    return false;\n}\n\nfunction mergeInputType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config && config.convertExtensions) ||\n                    node.kind === 'InputObjectTypeDefinition' ||\n                    existingNode.kind === 'InputObjectTypeDefinition'\n                    ? 'InputObjectTypeDefinition'\n                    : 'InputObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config && config.convertExtensions\n        ? {\n            ...node,\n            kind: 'InputObjectTypeDefinition',\n        }\n        : node;\n}\n\nfunction mergeInterface(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config && config.convertExtensions) ||\n                    node.kind === 'InterfaceTypeDefinition' ||\n                    existingNode.kind === 'InterfaceTypeDefinition'\n                    ? 'InterfaceTypeDefinition'\n                    : 'InterfaceTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config && config.convertExtensions\n        ? {\n            ...node,\n            kind: 'InterfaceTypeDefinition',\n        }\n        : node;\n}\n\nfunction alreadyExists(arr, other) {\n    return !!arr.find(i => i.name.value === other.name.value);\n}\nfunction mergeNamedTypeArray(first, second, config) {\n    const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\n\nfunction mergeType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config && config.convertExtensions) ||\n                    node.kind === 'ObjectTypeDefinition' ||\n                    existingNode.kind === 'ObjectTypeDefinition'\n                    ? 'ObjectTypeDefinition'\n                    : 'ObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n                interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config && config.convertExtensions\n        ? {\n            ...node,\n            kind: 'ObjectTypeDefinition',\n        }\n        : node;\n}\n\nfunction mergeScalar(node, existingNode, config) {\n    if (existingNode) {\n        return {\n            name: node.name,\n            description: node['description'] || existingNode['description'],\n            kind: (config && config.convertExtensions) ||\n                node.kind === 'ScalarTypeDefinition' ||\n                existingNode.kind === 'ScalarTypeDefinition'\n                ? 'ScalarTypeDefinition'\n                : 'ScalarTypeExtension',\n            loc: node.loc,\n            directives: mergeDirectives(node.directives, existingNode.directives, config),\n        };\n    }\n    return config && config.convertExtensions\n        ? {\n            ...node,\n            kind: 'ScalarTypeDefinition',\n        }\n        : node;\n}\n\nfunction mergeUnion(first, second, config) {\n    if (second) {\n        return {\n            name: first.name,\n            description: first['description'] || second['description'],\n            directives: mergeDirectives(first.directives, second.directives, config),\n            kind: (config && config.convertExtensions) ||\n                first.kind === 'UnionTypeDefinition' ||\n                second.kind === 'UnionTypeDefinition'\n                ? 'UnionTypeDefinition'\n                : 'UnionTypeExtension',\n            loc: first.loc,\n            types: mergeNamedTypeArray(first.types, second.types, config),\n        };\n    }\n    return config && config.convertExtensions\n        ? {\n            ...first,\n            kind: 'UnionTypeDefinition',\n        }\n        : first;\n}\n\nfunction mergeGraphQLNodes(nodes, config) {\n    return nodes.reduce((prev, nodeDefinition) => {\n        const node = nodeDefinition;\n        if (node && node.name && node.name.value) {\n            const name = node.name.value;\n            if (config && config.commentDescriptions) {\n                collectComment(node);\n            }\n            if (config &&\n                config.exclusions &&\n                (config.exclusions.includes(name + '.*') || config.exclusions.includes(name))) {\n                delete prev[name];\n            }\n            else if (isGraphQLType(nodeDefinition) || isGraphQLTypeExtension(nodeDefinition)) {\n                prev[name] = mergeType(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLEnum(nodeDefinition) || isGraphQLEnumExtension(nodeDefinition)) {\n                prev[name] = mergeEnum(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLUnion(nodeDefinition) || isGraphQLUnionExtension(nodeDefinition)) {\n                prev[name] = mergeUnion(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLScalar(nodeDefinition) || isGraphQLScalarExtension(nodeDefinition)) {\n                prev[name] = mergeScalar(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLInputType(nodeDefinition) || isGraphQLInputTypeExtension(nodeDefinition)) {\n                prev[name] = mergeInputType(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLInterface(nodeDefinition) || isGraphQLInterfaceExtension(nodeDefinition)) {\n                prev[name] = mergeInterface(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLDirective(nodeDefinition)) {\n                prev[name] = mergeDirective(nodeDefinition, prev[name]);\n            }\n        }\n        return prev;\n    }, {});\n}\n\nfunction mergeTypeDefs(types, config) {\n    resetComments();\n    const doc = {\n        kind: Kind.DOCUMENT,\n        definitions: mergeGraphQLTypes(types, {\n            useSchemaDefinition: true,\n            forceSchemaDefinition: false,\n            throwOnConflict: false,\n            commentDescriptions: false,\n            ...config,\n        }),\n    };\n    let result;\n    if (config && config.commentDescriptions) {\n        result = printWithComments(doc);\n    }\n    else {\n        result = doc;\n    }\n    resetComments();\n    return result;\n}\nfunction mergeGraphQLTypes(types, config) {\n    resetComments();\n    const allNodes = types\n        .map(type => {\n        if (Array.isArray(type)) {\n            type = mergeTypeDefs(type);\n        }\n        if (isSchema(type)) {\n            return parse(printSchemaWithDirectives(type));\n        }\n        else if (isStringTypes(type) || isSourceTypes(type)) {\n            return parse(type);\n        }\n        return type;\n    })\n        .map(ast => ast.definitions)\n        .reduce((defs, newDef = []) => [...defs, ...newDef], []);\n    // XXX: right now we don't handle multiple schema definitions\n    let schemaDef = allNodes.filter(isSchemaDefinition).reduce((def, node) => {\n        node.operationTypes\n            .filter(op => op.type.name.value)\n            .forEach(op => {\n            def[op.operation] = op.type.name.value;\n        });\n        return def;\n    }, {\n        query: null,\n        mutation: null,\n        subscription: null,\n    });\n    const mergedNodes = mergeGraphQLNodes(allNodes, config);\n    const allTypes = Object.keys(mergedNodes);\n    if (config && config.sort) {\n        allTypes.sort(typeof config.sort === 'function' ? config.sort : undefined);\n    }\n    if (config && config.useSchemaDefinition) {\n        const queryType = schemaDef.query ? schemaDef.query : allTypes.find(t => t === 'Query');\n        const mutationType = schemaDef.mutation ? schemaDef.mutation : allTypes.find(t => t === 'Mutation');\n        const subscriptionType = schemaDef.subscription ? schemaDef.subscription : allTypes.find(t => t === 'Subscription');\n        schemaDef = {\n            query: queryType,\n            mutation: mutationType,\n            subscription: subscriptionType,\n        };\n    }\n    const schemaDefinition = createSchemaDefinition(schemaDef, {\n        force: config.forceSchemaDefinition,\n    });\n    if (!schemaDefinition) {\n        return Object.values(mergedNodes);\n    }\n    return [...Object.values(mergedNodes), parse(schemaDefinition).definitions[0]];\n}\n\nfunction travelSchemaPossibleExtensions(schema, hooks) {\n    hooks.onSchema(schema);\n    const typesMap = schema.getTypeMap();\n    for (const [, type] of Object.entries(typesMap)) {\n        const isPredefinedScalar = isScalarType(type) && isSpecifiedScalarType(type);\n        const isIntrospection = isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (isObjectType(type)) {\n            hooks.onObjectType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onObjectField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onObjectFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (isInterfaceType(type)) {\n            hooks.onInterface(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInterfaceField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onInterfaceFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (isInputObjectType(type)) {\n            hooks.onInputType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInputFieldType(type, field);\n            }\n        }\n        else if (isUnionType(type)) {\n            hooks.onUnion(type);\n        }\n        else if (isScalarType(type)) {\n            hooks.onScalar(type);\n        }\n        else if (isEnumType(type)) {\n            hooks.onEnum(type);\n            for (const value of type.getValues()) {\n                hooks.onEnumValue(type, value);\n            }\n        }\n    }\n}\nfunction mergeExtensions(extensions) {\n    return extensions.reduce((result, extensionObj) => [result, extensionObj].reduce(mergeDeep, {}), {});\n}\nfunction applyExtensionObject(obj, extensions) {\n    if (!obj) {\n        return;\n    }\n    obj.extensions = [obj.extensions || {}, extensions || {}].reduce(mergeDeep, {});\n}\nfunction applyExtensions(schema, extensions) {\n    applyExtensionObject(schema, extensions.schemaExtensions);\n    for (const [typeName, data] of Object.entries(extensions.types || {})) {\n        const type = schema.getType(typeName);\n        if (type) {\n            applyExtensionObject(type, data.extensions);\n            if (data.type === 'object' || data.type === 'interface') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    if (field) {\n                        applyExtensionObject(field, fieldData.extensions);\n                        for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n                            applyExtensionObject(field.args.find(a => a.name === arg), argData);\n                        }\n                    }\n                }\n            }\n            else if (data.type === 'input') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    applyExtensionObject(field, fieldData.extensions);\n                }\n            }\n            else if (data.type === 'enum') {\n                for (const [valueName, valueData] of Object.entries(data.values)) {\n                    const value = type.getValue(valueName);\n                    applyExtensionObject(value, valueData);\n                }\n            }\n        }\n    }\n    return schema;\n}\nfunction extractExtensionsFromSchema(schema) {\n    const result = {\n        schemaExtensions: {},\n        types: {},\n    };\n    travelSchemaPossibleExtensions(schema, {\n        onSchema: schema => (result.schemaExtensions = schema.extensions || {}),\n        onObjectType: type => (result.types[type.name] = { fields: {}, type: 'object', extensions: type.extensions || {} }),\n        onObjectField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onObjectFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {}),\n        onInterface: type => (result.types[type.name] = { fields: {}, type: 'interface', extensions: type.extensions || {} }),\n        onInterfaceField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onInterfaceFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] =\n            arg.extensions || {}),\n        onEnum: type => (result.types[type.name] = { values: {}, type: 'enum', extensions: type.extensions || {} }),\n        onEnumValue: (type, value) => (result.types[type.name].values[value.name] = value.extensions || {}),\n        onScalar: type => (result.types[type.name] = { type: 'scalar', extensions: type.extensions || {} }),\n        onUnion: type => (result.types[type.name] = { type: 'union', extensions: type.extensions || {} }),\n        onInputType: type => (result.types[type.name] = { fields: {}, type: 'input', extensions: type.extensions || {} }),\n        onInputFieldType: (type, field) => (result.types[type.name].fields[field.name] = { extensions: field.extensions || {} }),\n    });\n    return result;\n}\n\nconst defaultResolverValidationOptions = {\n    requireResolversForArgs: false,\n    requireResolversForNonScalar: false,\n    requireResolversForAllFields: false,\n    requireResolversForResolveType: false,\n    allowResolversNotInSchema: true,\n};\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\nfunction mergeSchemas(config) {\n    const typeDefs = mergeTypes(config);\n    const extractedResolvers = [];\n    const extractedExtensions = [];\n    for (const schema of config.schemas) {\n        extractedResolvers.push(getResolversFromSchema(schema));\n        extractedExtensions.push(extractExtensionsFromSchema(schema));\n    }\n    extractedResolvers.push(...ensureResolvers(config));\n    const resolvers = mergeResolvers(extractedResolvers, config);\n    const extensions = mergeExtensions(extractedExtensions);\n    return makeSchema({ resolvers, typeDefs, extensions }, config);\n}\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\nasync function mergeSchemasAsync(config) {\n    const [typeDefs, resolvers, extensions] = await Promise.all([\n        mergeTypes(config),\n        Promise.all(config.schemas.map(async (schema) => getResolversFromSchema(schema))).then(extractedResolvers => mergeResolvers([...extractedResolvers, ...ensureResolvers(config)], config)),\n        Promise.all(config.schemas.map(async (schema) => extractExtensionsFromSchema(schema))).then(extractedExtensions => mergeExtensions(extractedExtensions)),\n    ]);\n    return makeSchema({ resolvers, typeDefs, extensions }, config);\n}\nfunction mergeTypes({ schemas, typeDefs, ...config }) {\n    return mergeTypeDefs([...schemas, ...(typeDefs ? asArray(typeDefs) : [])], config);\n}\nfunction ensureResolvers(config) {\n    return config.resolvers ? asArray(config.resolvers) : [];\n}\nfunction makeSchema({ resolvers, typeDefs, extensions, }, config) {\n    let schema = typeof typeDefs === 'string' ? buildSchema(typeDefs, config) : buildASTSchema(typeDefs, config);\n    // add resolvers\n    if (resolvers) {\n        schema = addResolversToSchema({\n            schema,\n            resolvers,\n            resolverValidationOptions: {\n                ...defaultResolverValidationOptions,\n                ...(config.resolverValidationOptions || {}),\n            },\n        });\n    }\n    // use logger\n    if (config.logger) {\n        schema = addErrorLoggingToSchema(schema, config.logger);\n    }\n    // use schema directives\n    if (config.schemaDirectives) {\n        SchemaDirectiveVisitor.visitSchemaDirectives(schema, config.schemaDirectives);\n    }\n    // extensions\n    applyExtensions(schema, extensions);\n    return schema;\n}\n\nexport { applyExtensions, collectComment, extractExtensionsFromSchema, extractType, isGraphQLDirective, isGraphQLEnum, isGraphQLEnumExtension, isGraphQLInputType, isGraphQLInputTypeExtension, isGraphQLInterface, isGraphQLInterfaceExtension, isGraphQLScalar, isGraphQLScalarExtension, isGraphQLType, isGraphQLTypeExtension, isGraphQLUnion, isGraphQLUnionExtension, isListTypeNode, isNonNullTypeNode, isSchemaDefinition, isSourceTypes, isStringTypes, isWrappingTypeNode, mergeArguments, mergeDirective, mergeDirectives, mergeEnum, mergeEnumValues, mergeExtensions, mergeFields, mergeGraphQLNodes, mergeGraphQLTypes, mergeInputType, mergeInterface, mergeNamedTypeArray, mergeResolvers, mergeSchemas, mergeSchemasAsync, mergeType, mergeTypeDefs, mergeUnion, printComment, printTypeNode, printWithComments, pushComment, resetComments, travelSchemaPossibleExtensions };\n//# sourceMappingURL=index.esm.js.map\n","import { isValidPath, parseGraphQLSDL, } from '@graphql-tools/utils';\nimport { isAbsolute, resolve } from 'path';\nimport { readFile, readFileSync, pathExists, pathExistsSync } from 'fs-extra';\nimport { cwd as processCwd } from 'process';\nimport { isExecutableDefinitionNode, Kind } from 'graphql';\nimport { processImport } from '@graphql-tools/import';\nimport { mergeTypeDefs } from '@graphql-tools/merge';\nconst FILE_EXTENSIONS = ['.gql', '.gqls', '.graphql', '.graphqls'];\nfunction isGraphQLImportFile(rawSDL) {\n    const trimmedRawSDL = rawSDL.trim();\n    return trimmedRawSDL.startsWith('# import') || trimmedRawSDL.startsWith('#import');\n}\n/**\n * This loader loads documents and type definitions from `.graphql` files.\n *\n * You can load a single source:\n *\n * ```js\n * const schema = await loadSchema('schema.graphql', {\n *   loaders: [\n *     new GraphQLFileLoader()\n *   ]\n * });\n * ```\n *\n * Or provide a glob pattern to load multiple sources:\n *\n * ```js\n * const schema = await loadSchema('graphql/*.graphql', {\n *   loaders: [\n *     new GraphQLFileLoader()\n *   ]\n * });\n * ```\n */\nexport class GraphQLFileLoader {\n    loaderId() {\n        return 'graphql-file';\n    }\n    async canLoad(pointer, options) {\n        if (isValidPath(pointer)) {\n            if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n                const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || processCwd(), pointer);\n                return pathExists(normalizedFilePath);\n            }\n        }\n        return false;\n    }\n    canLoadSync(pointer, options) {\n        if (isValidPath(pointer)) {\n            if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n                const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || processCwd(), pointer);\n                return pathExistsSync(normalizedFilePath);\n            }\n        }\n        return false;\n    }\n    async load(pointer, options) {\n        const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || processCwd(), pointer);\n        const rawSDL = await readFile(normalizedFilePath, { encoding: 'utf8' });\n        return this.handleFileContent(rawSDL, pointer, options);\n    }\n    loadSync(pointer, options) {\n        const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || processCwd(), pointer);\n        const rawSDL = readFileSync(normalizedFilePath, { encoding: 'utf8' });\n        return this.handleFileContent(rawSDL, pointer, options);\n    }\n    handleFileContent(rawSDL, pointer, options) {\n        if (!options.skipGraphQLImport && isGraphQLImportFile(rawSDL)) {\n            const document = processImport(pointer, options.cwd);\n            const typeSystemDefinitions = document.definitions\n                .filter(d => !isExecutableDefinitionNode(d))\n                .map(definition => ({\n                kind: Kind.DOCUMENT,\n                definitions: [definition],\n            }));\n            const mergedTypeDefs = mergeTypeDefs(typeSystemDefinitions, { useSchemaDefinition: false });\n            const executableDefinitions = document.definitions.filter(isExecutableDefinitionNode);\n            return {\n                location: pointer,\n                document: {\n                    ...mergedTypeDefs,\n                    definitions: [...mergedTypeDefs.definitions, ...executableDefinitions],\n                },\n            };\n        }\n        return parseGraphQLSDL(pointer, rawSDL, options);\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":["compareNodes","getDescription","visit","print","Source","Kind","isNotEqual","isSchema","parse","printSchemaWithDirectives","createSchemaDefinition","isValidPath","isAbsolute","resolve","processCwd","pathExists","pathExistsSync","readFile","readFileSync","processImport","isExecutableDefinitionNode","parseGraphQLSDL"],"mappings":";;;;;;;;;;;AAiFA,SAAS,cAAc,CAAC,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE;AAC9C,IAAI,MAAM,MAAM,GAAG,oBAAoB,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAChF,IAAI,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC/B,QAAQ,MAAM,CAAC,IAAI,CAACA,kBAAY,CAAC,CAAC;AAClC,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,oBAAoB,CAAC,IAAI,EAAE;AACpC,IAAI,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,OAAO,KAAK;AACzC,QAAQ,MAAM,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,KAAK,KAAK,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC3E,QAAQ,IAAI,CAAC,GAAG,EAAE;AAClB,YAAY,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;AACzC,SAAS;AACT,QAAQ,OAAO,GAAG,CAAC;AACnB,KAAK,EAAE,EAAE,CAAC,CAAC;AACX,CAAC;AACD;AACA,IAAI,gBAAgB,GAAG,EAAE,CAAC;AAC1B,SAAS,aAAa,GAAG;AACzB,IAAI,gBAAgB,GAAG,EAAE,CAAC;AAC1B,CAAC;AACD,SAAS,cAAc,CAAC,IAAI,EAAE;AAC9B,IAAI,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;AACvC,IAAI,WAAW,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;AAClC,IAAI,QAAQ,IAAI,CAAC,IAAI;AACrB,QAAQ,KAAK,oBAAoB;AACjC,YAAY,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI;AACzC,gBAAgB,WAAW,CAAC,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACjE,aAAa,CAAC,CAAC;AACf,YAAY,MAAM;AAClB,QAAQ,KAAK,sBAAsB,CAAC;AACpC,QAAQ,KAAK,2BAA2B,CAAC;AACzC,QAAQ,KAAK,yBAAyB;AACtC,YAAY,IAAI,IAAI,CAAC,MAAM,EAAE;AAC7B,gBAAgB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,KAAK;AAC/C,oBAAoB,WAAW,CAAC,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACrE,oBAAoB,IAAI,qBAAqB,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,SAAS,EAAE;AACzE,wBAAwB,KAAK,CAAC,SAAS,CAAC,OAAO,CAAC,GAAG,IAAI;AACvD,4BAA4B,WAAW,CAAC,GAAG,EAAE,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC3F,yBAAyB,CAAC,CAAC;AAC3B,qBAAqB;AACrB,iBAAiB,CAAC,CAAC;AACnB,aAAa;AACb,YAAY,MAAM;AAClB,KAAK;AACL,CAAC;AACD,SAAS,WAAW,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE;AACpD,IAAI,MAAM,OAAO,GAAGC,sBAAc,CAAC,IAAI,EAAE,EAAE,mBAAmB,EAAE,IAAI,EAAE,CAAC,CAAC;AACxE,IAAI,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AAC7D,QAAQ,OAAO;AACf,KAAK;AACL,IAAI,MAAM,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC;AAC1B,IAAI,IAAI,KAAK,EAAE;AACf,QAAQ,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACzB,QAAQ,IAAI,QAAQ,EAAE;AACtB,YAAY,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAChC,SAAS;AACT,KAAK;AACL,IAAI,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChC,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;AACjC,QAAQ,gBAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC;AACpC,KAAK;AACL,IAAI,gBAAgB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACzC,CAAC;AACD,SAAS,YAAY,CAAC,OAAO,EAAE;AAC/B,IAAI,OAAO,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACnD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI,CAAC,UAAU,EAAE,SAAS,EAAE;AACrC,IAAI,OAAO,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,IAAI,EAAE,CAAC,GAAG,EAAE,CAAC;AAC7E,CAAC;AACD,SAAS,cAAc,CAAC,EAAE,EAAE;AAC5B,IAAI,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,KAAK;AACrD,QAAQ,MAAM,IAAI,GAAG,EAAE,CAAC;AACxB,QAAQ,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,GAAG,KAAK;AAClD,YAAY,IAAI,CAAC,QAAQ,EAAE,WAAW,EAAE,QAAQ,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;AACjE,gBAAgB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC3C,aAAa;AACb,YAAY,OAAO,IAAI,CAAC,GAAG,CAAC,CAAC;AAC7B,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AACzB,QAAQ,MAAM,GAAG,GAAG,CAAC,GAAG,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC3D,QAAQ,MAAM,KAAK,GAAG,EAAE,CAAC;AACzB,QAAQ,IAAI,gBAAgB,CAAC,GAAG,CAAC,EAAE;AACnC,YAAY,KAAK,CAAC,IAAI,CAAC,GAAG,gBAAgB,CAAC,GAAG,CAAC,CAAC,CAAC;AACjD,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,WAAW,EAAE,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;AACpF,KAAK,CAAC;AACN,CAAC;AACD,SAAS,MAAM,CAAC,WAAW,EAAE;AAC7B,IAAI,OAAO,WAAW,IAAI,CAAC,EAAE,EAAE,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;AACpE,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS,KAAK,CAAC,KAAK,EAAE;AACtB,IAAI,OAAO,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;AACnF,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS,IAAI,CAAC,KAAK,EAAE,WAAW,EAAE,GAAG,EAAE;AACvC,IAAI,OAAO,WAAW,GAAG,KAAK,GAAG,WAAW,IAAI,GAAG,IAAI,EAAE,CAAC,GAAG,EAAE,CAAC;AAChE,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS,gBAAgB,CAAC,KAAK,EAAE,aAAa,EAAE;AAChD,IAAI,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;AACnD,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,KAAK,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAChF,UAAU,CAAC,GAAG,EAAE,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC;AACjD,UAAU,CAAC,KAAK,EAAE,aAAa,GAAG,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,CAAC;AACnE,CAAC;AACD;AACA;AACA;AACA;AACA,SAAS,iBAAiB,CAAC,GAAG,EAAE;AAChC,IAAI,OAAOC,aAAK,CAAC,GAAG,EAAE;AACtB,QAAQ,KAAK,EAAE;AACf,YAAY,IAAI,EAAE,IAAI,IAAI,IAAI,CAAC,KAAK;AACpC,YAAY,QAAQ,EAAE,IAAI,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;AAC7C;AACA,YAAY,QAAQ,EAAE,IAAI,IAAI,CAAC,EAAE,IAAI,CAAC,WAAW;AACjD,iBAAiB,GAAG,CAAC,OAAO,IAAI,CAAC,EAAE,OAAO,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;AAChF,iBAAiB,IAAI,CAAC,EAAE,CAAC;AACzB,iBAAiB,IAAI,EAAE,CAAC,EAAE,CAAC;AAC3B,YAAY,uBAAuB,EAAE,IAAI,IAAI,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,EAAE,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;AAC9E,YAAY,kBAAkB,EAAE,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,CAAC,EAAE,QAAQ,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC;AACxH,YAAY,YAAY,EAAE,CAAC,EAAE,UAAU,EAAE,KAAK,KAAK,CAAC,UAAU,CAAC;AAC/D,YAAY,KAAK,EAAE,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,UAAU,EAAE,YAAY,EAAE,KAAK,IAAI,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,YAAY,CAAC,EAAE,IAAI,CAAC;AACrM,YAAY,QAAQ,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC;AAC9E;AACA,YAAY,QAAQ,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,KAAK;AAC1C,YAAY,UAAU,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,KAAK;AAC5C,YAAY,WAAW,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,aAAa,EAAE,EAAE,GAAG,KAAK,aAAa,GAAG,gBAAgB,CAAC,KAAK,EAAE,GAAG,KAAK,aAAa,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC;AACzJ,YAAY,YAAY,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;AACnE,YAAY,SAAS,EAAE,MAAM,MAAM;AACnC,YAAY,SAAS,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,KAAK;AAC3C,YAAY,SAAS,EAAE,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AAChE,YAAY,WAAW,EAAE,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;AAClE,YAAY,WAAW,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,CAAC,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;AACjE;AACA,YAAY,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;AACnG;AACA,YAAY,SAAS,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,IAAI;AACzC,YAAY,QAAQ,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AAC/C,YAAY,WAAW,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AACjD;AACA,YAAY,gBAAgB,EAAE,CAAC,EAAE,UAAU,EAAE,cAAc,EAAE,KAAK,IAAI,CAAC,CAAC,QAAQ,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,cAAc,CAAC,CAAC,EAAE,GAAG,CAAC;AACrI,YAAY,oBAAoB,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,IAAI,CAAC,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AAC9H,YAAY,oBAAoB,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,IAAI,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AAC7M,YAAY,eAAe,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,CAAC,EAAE,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;AACtL,YAAY,oBAAoB,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,YAAY,EAAE,UAAU,EAAE,KAAK,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,EAAE,YAAY,CAAC,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AAChL,YAAY,uBAAuB,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,IAAI,CAAC,CAAC,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AAC3J,YAAY,mBAAmB,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,KAAK,IAAI,CAAC,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC,CAAC;AACjM,YAAY,kBAAkB,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,IAAI,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AACjJ,YAAY,mBAAmB,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,IAAI,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AACnH,YAAY,yBAAyB,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,IAAI,CAAC,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AACzJ,YAAY,mBAAmB,EAAE,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,IAAI,CAAC,CAAC,eAAe,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;AACpH,YAAY,mBAAmB,EAAE,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,IAAI,CAAC,CAAC,aAAa,EAAE,IAAI,EAAE,IAAI,CAAC,aAAa,EAAE,IAAI,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;AACnM,YAAY,sBAAsB,EAAE,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,IAAI,CAAC,CAAC,kBAAkB,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;AACjJ,YAAY,kBAAkB,EAAE,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,KAAK,IAAI,CAAC,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,CAAC;AACvL,YAAY,iBAAiB,EAAE,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,IAAI,CAAC,CAAC,aAAa,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;AACvI,YAAY,wBAAwB,EAAE,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,MAAM,EAAE,KAAK,IAAI,CAAC,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;AAC/I,YAAY,mBAAmB,EAAE,cAAc,CAAC,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,CAAC,WAAW,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;AAC/K,SAAS;AACT,KAAK,CAAC,CAAC;AACP,CAAC;AACD,SAAS,qBAAqB,CAAC,IAAI,EAAE;AACrC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,iBAAiB,CAAC;AAC3C,CAAC;AACD;AACA,SAAS,sBAAsB,CAAC,aAAa,EAAE,cAAc,EAAE;AAC/D,IAAI,OAAO,CAAC,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS,IAAI,SAAS,CAAC,IAAI,CAAC,KAAK,KAAK,cAAc,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACjG,CAAC;AACD,SAAS,iBAAiB,CAAC,IAAI,EAAE,QAAQ,EAAE;AAC3C,IAAI,OAAO,QAAQ,CAAC,IAAI,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,KAAK,KAAK,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9D,CAAC;AACD,SAAS,gBAAgB,CAAC,EAAE,EAAE,EAAE,EAAE;AAClC,IAAI,MAAM,MAAM,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;AAC3B,IAAI,KAAK,MAAM,QAAQ,IAAI,EAAE,EAAE;AAC/B,QAAQ,MAAM,aAAa,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC1F,QAAQ,IAAI,aAAa,GAAG,CAAC,CAAC,EAAE;AAChC,YAAY,MAAM,WAAW,GAAG,MAAM,CAAC,aAAa,CAAC,CAAC;AACtD,YAAY,IAAI,WAAW,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;AACxD,gBAAgB,MAAM,MAAM,GAAG,WAAW,CAAC,KAAK,CAAC,MAAM,CAAC;AACxD,gBAAgB,MAAM,MAAM,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC;AACrD;AACA,gBAAgB,WAAW,CAAC,KAAK,CAAC,MAAM,GAAG,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,CAAC,SAAS,EAAE,MAAM,KAAK;AACnG,oBAAoB,MAAM,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC;AAClD,oBAAoB,OAAO,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,SAAS,KAAK,SAAS,CAAC,KAAK,KAAK,KAAK,CAAC,CAAC;AAC5F,iBAAiB,CAAC,CAAC;AACnB,aAAa;AACb,iBAAiB;AACjB,gBAAgB,WAAW,CAAC,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;AACnD,aAAa;AACb,SAAS;AACT,aAAa;AACb,YAAY,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAClC,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,qBAAqB,CAAC,UAAU,EAAE;AAC3C,IAAI,OAAO,UAAU;AACrB,SAAS,GAAG,CAAC,CAAC,SAAS,EAAE,CAAC,EAAE,GAAG,KAAK;AACpC,QAAQ,MAAM,OAAO,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAClF,QAAQ,IAAI,OAAO,KAAK,CAAC,EAAE;AAC3B,YAAY,MAAM,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC,CAAC;AACrC,YAAY,SAAS,CAAC,SAAS,GAAG,gBAAgB,CAAC,SAAS,CAAC,SAAS,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC;AACvF,YAAY,OAAO,IAAI,CAAC;AACxB,SAAS;AACT,QAAQ,OAAO,SAAS,CAAC;AACzB,KAAK,CAAC;AACN,SAAS,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;AACxB,CAAC;AACD,SAAS,eAAe,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,MAAM,EAAE;AACnD,IAAI,MAAM,YAAY,GAAG,MAAM,IAAI,MAAM,CAAC,iBAAiB,CAAC;AAC5D,IAAI,MAAM,MAAM,GAAG,YAAY,GAAG,EAAE,GAAG,EAAE,CAAC;AAC1C,IAAI,MAAM,OAAO,GAAG,YAAY,GAAG,EAAE,GAAG,EAAE,CAAC;AAC3C,IAAI,MAAM,MAAM,GAAG,qBAAqB,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC;AACtD,IAAI,KAAK,MAAM,SAAS,IAAI,OAAO,EAAE;AACrC,QAAQ,IAAI,sBAAsB,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE;AACvD,YAAY,MAAM,sBAAsB,GAAG,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,KAAK,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACxG,YAAY,MAAM,iBAAiB,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC;AACrE,YAAY,MAAM,CAAC,sBAAsB,CAAC,CAAC,SAAS,GAAG,gBAAgB,CAAC,SAAS,CAAC,SAAS,IAAI,EAAE,EAAE,iBAAiB,CAAC,SAAS,IAAI,EAAE,CAAC,CAAC;AACtI,SAAS;AACT,aAAa;AACb,YAAY,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AACnC,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,cAAc,CAAC,IAAI,EAAE,YAAY,EAAE;AAC5C,IAAI,MAAM,WAAW,GAAGC,aAAK,CAAC,IAAI,CAAC,CAAC;AACpC,IAAI,MAAM,mBAAmB,GAAGA,aAAK,CAAC,YAAY,CAAC,CAAC;AACpD,IAAI,MAAM,WAAW,GAAG,IAAI,MAAM,CAAC,6BAA6B,EAAE,GAAG,CAAC,CAAC;AACvE,IAAI,MAAM,aAAa,GAAG,WAAW,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,KAAK,mBAAmB,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC;AAChH,IAAI,IAAI,CAAC,aAAa,EAAE;AACxB,QAAQ,MAAM,IAAI,KAAK,CAAC,CAAC,mCAAmC,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,8BAA8B,EAAE,mBAAmB,CAAC,2BAA2B,EAAE,WAAW,CAAC,CAAC,CAAC,CAAC;AAC9K,KAAK;AACL,CAAC;AACD,SAAS,cAAc,CAAC,IAAI,EAAE,YAAY,EAAE;AAC5C,IAAI,IAAI,YAAY,EAAE;AACtB,QAAQ,cAAc,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;AAC3C,QAAQ,OAAO;AACf,YAAY,GAAG,IAAI;AACnB,YAAY,SAAS,EAAE;AACvB,gBAAgB,GAAG,YAAY,CAAC,SAAS;AACzC,gBAAgB,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC;AAClG,aAAa;AACb,SAAS,CAAC;AACV,KAAK;AACL,IAAI,OAAO,IAAI,CAAC;AAChB,CAAC;AACD,SAAS,gBAAgB,CAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE;AACpD,IAAI,OAAO,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,QAAQ,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC;AACtE,CAAC;AACD;AACA,SAAS,eAAe,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE;AAChD,IAAI,MAAM,YAAY,GAAG,IAAI,GAAG,EAAE,CAAC;AACnC,IAAI,KAAK,MAAM,UAAU,IAAI,KAAK,EAAE;AACpC,QAAQ,YAAY,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;AAC5D,KAAK;AACL,IAAI,KAAK,MAAM,WAAW,IAAI,MAAM,EAAE;AACtC,QAAQ,MAAM,SAAS,GAAG,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC;AACjD,QAAQ,IAAI,YAAY,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;AACzC,YAAY,MAAM,UAAU,GAAG,YAAY,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;AAC3D,YAAY,UAAU,CAAC,WAAW,GAAG,WAAW,CAAC,WAAW,IAAI,UAAU,CAAC,WAAW,CAAC;AACvF,YAAY,UAAU,CAAC,UAAU,GAAG,eAAe,CAAC,WAAW,CAAC,UAAU,EAAE,UAAU,CAAC,UAAU,CAAC,CAAC;AACnG,SAAS;AACT,aAAa;AACb,YAAY,YAAY,CAAC,GAAG,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;AACrD,SAAS;AACT,KAAK;AACL,IAAI,MAAM,MAAM,GAAG,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,CAAC;AAC9C,IAAI,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC/B,QAAQ,MAAM,CAAC,IAAI,CAACH,kBAAY,CAAC,CAAC;AAClC,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD;AACA,SAAS,SAAS,CAAC,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE;AACnC,IAAI,IAAI,EAAE,EAAE;AACZ,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,EAAE,CAAC,IAAI;AACzB,YAAY,WAAW,EAAE,EAAE,CAAC,aAAa,CAAC,IAAI,EAAE,CAAC,aAAa,CAAC;AAC/D,YAAY,IAAI,EAAE,CAAC,MAAM,IAAI,MAAM,CAAC,iBAAiB,KAAK,EAAE,CAAC,IAAI,KAAK,oBAAoB,IAAI,EAAE,CAAC,IAAI,KAAK,oBAAoB;AAC9H,kBAAkB,oBAAoB;AACtC,kBAAkB,mBAAmB;AACrC,YAAY,GAAG,EAAE,EAAE,CAAC,GAAG;AACvB,YAAY,UAAU,EAAE,eAAe,CAAC,EAAE,CAAC,UAAU,EAAE,EAAE,CAAC,UAAU,EAAE,MAAM,CAAC;AAC7E,YAAY,MAAM,EAAE,eAAe,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC;AACjE,SAAS,CAAC;AACV,KAAK;AACL,IAAI,OAAO,MAAM,IAAI,MAAM,CAAC,iBAAiB;AAC7C,UAAU;AACV,YAAY,GAAG,EAAE;AACjB,YAAY,IAAI,EAAE,oBAAoB;AACtC,SAAS;AACT,UAAU,EAAE,CAAC;AACb,CAAC;AACD;AACA,SAAS,aAAa,CAAC,KAAK,EAAE;AAC9B,IAAI,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC;AACrC,CAAC;AACD,SAAS,aAAa,CAAC,KAAK,EAAE;AAC9B,IAAI,OAAO,KAAK,YAAYI,cAAM,CAAC;AACnC,CAAC;AACD,SAAS,aAAa,CAAC,UAAU,EAAE;AACnC,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,sBAAsB,CAAC;AACtD,CAAC;AACD,SAAS,sBAAsB,CAAC,UAAU,EAAE;AAC5C,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,qBAAqB,CAAC;AACrD,CAAC;AACD,SAAS,aAAa,CAAC,UAAU,EAAE;AACnC,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,oBAAoB,CAAC;AACpD,CAAC;AACD,SAAS,sBAAsB,CAAC,UAAU,EAAE;AAC5C,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,mBAAmB,CAAC;AACnD,CAAC;AACD,SAAS,cAAc,CAAC,UAAU,EAAE;AACpC,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,qBAAqB,CAAC;AACrD,CAAC;AACD,SAAS,uBAAuB,CAAC,UAAU,EAAE;AAC7C,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,oBAAoB,CAAC;AACpD,CAAC;AACD,SAAS,eAAe,CAAC,UAAU,EAAE;AACrC,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,sBAAsB,CAAC;AACtD,CAAC;AACD,SAAS,wBAAwB,CAAC,UAAU,EAAE;AAC9C,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,qBAAqB,CAAC;AACrD,CAAC;AACD,SAAS,kBAAkB,CAAC,UAAU,EAAE;AACxC,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,2BAA2B,CAAC;AAC3D,CAAC;AACD,SAAS,2BAA2B,CAAC,UAAU,EAAE;AACjD,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,0BAA0B,CAAC;AAC1D,CAAC;AACD,SAAS,kBAAkB,CAAC,UAAU,EAAE;AACxC,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,yBAAyB,CAAC;AACzD,CAAC;AACD,SAAS,2BAA2B,CAAC,UAAU,EAAE;AACjD,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,wBAAwB,CAAC;AACxD,CAAC;AACD,SAAS,kBAAkB,CAAC,UAAU,EAAE;AACxC,IAAI,OAAO,UAAU,CAAC,IAAI,KAAK,qBAAqB,CAAC;AACrD,CAAC;AACD,SAAS,WAAW,CAAC,IAAI,EAAE;AAC3B,IAAI,IAAI,WAAW,GAAG,IAAI,CAAC;AAC3B,IAAI,OAAO,WAAW,CAAC,IAAI,KAAK,UAAU,IAAI,WAAW,CAAC,IAAI,KAAK,aAAa,EAAE;AAClF,QAAQ,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC;AACvC,KAAK;AACL,IAAI,OAAO,WAAW,CAAC;AACvB,CAAC;AACD,SAAS,kBAAkB,CAAC,IAAI,EAAE;AAClC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAK,kBAAkB,CAAC;AAC5C,CAAC;AACD,SAAS,kBAAkB,CAAC,IAAI,EAAE;AAClC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAKC,YAAI,CAAC,UAAU,CAAC;AACzC,CAAC;AACD,SAAS,cAAc,CAAC,IAAI,EAAE;AAC9B,IAAI,OAAO,IAAI,CAAC,IAAI,KAAKA,YAAI,CAAC,SAAS,CAAC;AACxC,CAAC;AACD,SAAS,iBAAiB,CAAC,IAAI,EAAE;AACjC,IAAI,OAAO,IAAI,CAAC,IAAI,KAAKA,YAAI,CAAC,aAAa,CAAC;AAC5C,CAAC;AACD,SAAS,aAAa,CAAC,IAAI,EAAE;AAC7B,IAAI,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;AAC9B,QAAQ,OAAO,CAAC,CAAC,EAAE,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/C,KAAK;AACL,IAAI,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;AACjC,QAAQ,OAAO,CAAC,EAAE,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,KAAK;AACL,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;AAC3B,CAAC;AACD;AACA,SAAS,kBAAkB,CAAC,SAAS,EAAE,UAAU,EAAE;AACnD,IAAI,MAAM,MAAM,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,KAAK,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACvF,IAAI,IAAI,MAAM,EAAE;AAChB,QAAQ,MAAM,EAAE,GAAG,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC5C,QAAQ,MAAM,EAAE,GAAG,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAChD,QAAQ,IAAI,EAAE,CAAC,IAAI,CAAC,KAAK,KAAK,EAAE,CAAC,IAAI,CAAC,KAAK,EAAE;AAC7C,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,OAAO,EAAE,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,sDAAsD,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,mCAAmC,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AACzL,SAAS;AACT,KAAK;AACL,IAAI,OAAO,CAAC,CAAC,MAAM,CAAC;AACpB,CAAC;AACD,SAAS,WAAW,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE;AAC3C,IAAI,MAAM,MAAM,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;AAC3B,IAAI,KAAK,MAAM,KAAK,IAAI,EAAE,EAAE;AAC5B,QAAQ,IAAI,kBAAkB,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE;AAC/C,YAAY,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,KAAK,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACnF,YAAY,IAAI,MAAM,IAAI,MAAM,CAAC,eAAe,EAAE;AAClD,gBAAgB,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;AAC/D,aAAa;AACb,iBAAiB;AACjB,gBAAgB,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;AAC9D,aAAa;AACb,YAAY,IAAI,iBAAiB,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;AACpF,gBAAgB,QAAQ,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;AAC3C,aAAa;AACb,YAAY,QAAQ,CAAC,SAAS,GAAG,cAAc,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,EAAE,QAAQ,CAAC,SAAS,IAAI,EAAE,EAAE,MAAM,CAAC,CAAC;AAC5G,YAAY,QAAQ,CAAC,UAAU,GAAG,eAAe,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;AACjG,YAAY,QAAQ,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW,IAAI,QAAQ,CAAC,WAAW,CAAC;AAC7E,SAAS;AACT,aAAa;AACb,YAAY,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC/B,SAAS;AACT,KAAK;AACL,IAAI,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC/B,QAAQ,MAAM,CAAC,IAAI,CAACL,kBAAY,CAAC,CAAC;AAClC,KAAK;AACL,IAAI,IAAI,MAAM,IAAI,MAAM,CAAC,UAAU,EAAE;AACrC,QAAQ,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7G,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,gBAAgB,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,iBAAiB,GAAG,KAAK,EAAE;AACjE,IAAI,MAAM,KAAK,GAAG,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;AACxC,IAAI,MAAM,KAAK,GAAG,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;AACxC,IAAI,IAAIM,gBAAU,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE;AAClC,QAAQ,IAAI,sBAAsB,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,iBAAiB,CAAC,KAAK,KAAK,EAAE;AACjF,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,qBAAqB,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;AACrH,SAAS;AACT,KAAK;AACL,CAAC;AACD,SAAS,sBAAsB,CAAC,OAAO,EAAE,OAAO,EAAE,iBAAiB,GAAG,KAAK,EAAE;AAC7E;AACA,IAAI,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,EAAE;AACtE,QAAQ,OAAO,OAAO,CAAC,QAAQ,EAAE,KAAK,OAAO,CAAC,QAAQ,EAAE,CAAC;AACzD,KAAK;AACL;AACA,IAAI,IAAI,iBAAiB,CAAC,OAAO,CAAC,EAAE;AACpC,QAAQ,MAAM,MAAM,GAAG,iBAAiB,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,IAAI,GAAG,OAAO,CAAC;AAC3E,QAAQ,OAAO,sBAAsB,CAAC,MAAM,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;AAC5D,KAAK;AACL;AACA,IAAI,IAAI,iBAAiB,CAAC,OAAO,CAAC,EAAE;AACpC,QAAQ,OAAO,sBAAsB,CAAC,OAAO,EAAE,OAAO,EAAE,iBAAiB,CAAC,CAAC;AAC3E,KAAK;AACL;AACA,IAAI,IAAI,cAAc,CAAC,OAAO,CAAC,EAAE;AACjC,QAAQ,QAAQ,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,sBAAsB,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC;AAC9F,aAAa,iBAAiB,CAAC,OAAO,CAAC,IAAI,sBAAsB,CAAC,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;AAC9F,KAAK;AACL,IAAI,OAAO,KAAK,CAAC;AACjB,CAAC;AACD;AACA,SAAS,cAAc,CAAC,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE;AACpD,IAAI,IAAI,YAAY,EAAE;AACtB,QAAQ,IAAI;AACZ,YAAY,OAAO;AACnB,gBAAgB,IAAI,EAAE,IAAI,CAAC,IAAI;AAC/B,gBAAgB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,IAAI,YAAY,CAAC,aAAa,CAAC;AAC/E,gBAAgB,IAAI,EAAE,CAAC,MAAM,IAAI,MAAM,CAAC,iBAAiB;AACzD,oBAAoB,IAAI,CAAC,IAAI,KAAK,2BAA2B;AAC7D,oBAAoB,YAAY,CAAC,IAAI,KAAK,2BAA2B;AACrE,sBAAsB,2BAA2B;AACjD,sBAAsB,0BAA0B;AAChD,gBAAgB,GAAG,EAAE,IAAI,CAAC,GAAG;AAC7B,gBAAgB,MAAM,EAAE,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC;AACnF,gBAAgB,UAAU,EAAE,eAAe,CAAC,IAAI,CAAC,UAAU,EAAE,YAAY,CAAC,UAAU,EAAE,MAAM,CAAC;AAC7F,aAAa,CAAC;AACd,SAAS;AACT,QAAQ,OAAO,CAAC,EAAE;AAClB,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,oCAAoC,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACrG,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,IAAI,MAAM,CAAC,iBAAiB;AAC7C,UAAU;AACV,YAAY,GAAG,IAAI;AACnB,YAAY,IAAI,EAAE,2BAA2B;AAC7C,SAAS;AACT,UAAU,IAAI,CAAC;AACf,CAAC;AACD;AACA,SAAS,cAAc,CAAC,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE;AACpD,IAAI,IAAI,YAAY,EAAE;AACtB,QAAQ,IAAI;AACZ,YAAY,OAAO;AACnB,gBAAgB,IAAI,EAAE,IAAI,CAAC,IAAI;AAC/B,gBAAgB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,IAAI,YAAY,CAAC,aAAa,CAAC;AAC/E,gBAAgB,IAAI,EAAE,CAAC,MAAM,IAAI,MAAM,CAAC,iBAAiB;AACzD,oBAAoB,IAAI,CAAC,IAAI,KAAK,yBAAyB;AAC3D,oBAAoB,YAAY,CAAC,IAAI,KAAK,yBAAyB;AACnE,sBAAsB,yBAAyB;AAC/C,sBAAsB,wBAAwB;AAC9C,gBAAgB,GAAG,EAAE,IAAI,CAAC,GAAG;AAC7B,gBAAgB,MAAM,EAAE,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC;AACnF,gBAAgB,UAAU,EAAE,eAAe,CAAC,IAAI,CAAC,UAAU,EAAE,YAAY,CAAC,UAAU,EAAE,MAAM,CAAC;AAC7F,aAAa,CAAC;AACd,SAAS;AACT,QAAQ,OAAO,CAAC,EAAE;AAClB,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,mCAAmC,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AACpG,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,IAAI,MAAM,CAAC,iBAAiB;AAC7C,UAAU;AACV,YAAY,GAAG,IAAI;AACnB,YAAY,IAAI,EAAE,yBAAyB;AAC3C,SAAS;AACT,UAAU,IAAI,CAAC;AACf,CAAC;AACD;AACA,SAAS,aAAa,CAAC,GAAG,EAAE,KAAK,EAAE;AACnC,IAAI,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,KAAK,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAC9D,CAAC;AACD,SAAS,mBAAmB,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE;AACpD,IAAI,MAAM,MAAM,GAAG,CAAC,GAAG,MAAM,EAAE,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AAChF,IAAI,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC/B,QAAQ,MAAM,CAAC,IAAI,CAACN,kBAAY,CAAC,CAAC;AAClC,KAAK;AACL,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD;AACA,SAAS,SAAS,CAAC,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE;AAC/C,IAAI,IAAI,YAAY,EAAE;AACtB,QAAQ,IAAI;AACZ,YAAY,OAAO;AACnB,gBAAgB,IAAI,EAAE,IAAI,CAAC,IAAI;AAC/B,gBAAgB,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,IAAI,YAAY,CAAC,aAAa,CAAC;AAC/E,gBAAgB,IAAI,EAAE,CAAC,MAAM,IAAI,MAAM,CAAC,iBAAiB;AACzD,oBAAoB,IAAI,CAAC,IAAI,KAAK,sBAAsB;AACxD,oBAAoB,YAAY,CAAC,IAAI,KAAK,sBAAsB;AAChE,sBAAsB,sBAAsB;AAC5C,sBAAsB,qBAAqB;AAC3C,gBAAgB,GAAG,EAAE,IAAI,CAAC,GAAG;AAC7B,gBAAgB,MAAM,EAAE,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,EAAE,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC;AACnF,gBAAgB,UAAU,EAAE,eAAe,CAAC,IAAI,CAAC,UAAU,EAAE,YAAY,CAAC,UAAU,EAAE,MAAM,CAAC;AAC7F,gBAAgB,UAAU,EAAE,mBAAmB,CAAC,IAAI,CAAC,UAAU,EAAE,YAAY,CAAC,UAAU,EAAE,MAAM,CAAC;AACjG,aAAa,CAAC;AACd,SAAS;AACT,QAAQ,OAAO,CAAC,EAAE;AAClB,YAAY,MAAM,IAAI,KAAK,CAAC,CAAC,8BAA8B,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AAC/F,SAAS;AACT,KAAK;AACL,IAAI,OAAO,MAAM,IAAI,MAAM,CAAC,iBAAiB;AAC7C,UAAU;AACV,YAAY,GAAG,IAAI;AACnB,YAAY,IAAI,EAAE,sBAAsB;AACxC,SAAS;AACT,UAAU,IAAI,CAAC;AACf,CAAC;AACD;AACA,SAAS,WAAW,CAAC,IAAI,EAAE,YAAY,EAAE,MAAM,EAAE;AACjD,IAAI,IAAI,YAAY,EAAE;AACtB,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,IAAI,CAAC,IAAI;AAC3B,YAAY,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,IAAI,YAAY,CAAC,aAAa,CAAC;AAC3E,YAAY,IAAI,EAAE,CAAC,MAAM,IAAI,MAAM,CAAC,iBAAiB;AACrD,gBAAgB,IAAI,CAAC,IAAI,KAAK,sBAAsB;AACpD,gBAAgB,YAAY,CAAC,IAAI,KAAK,sBAAsB;AAC5D,kBAAkB,sBAAsB;AACxC,kBAAkB,qBAAqB;AACvC,YAAY,GAAG,EAAE,IAAI,CAAC,GAAG;AACzB,YAAY,UAAU,EAAE,eAAe,CAAC,IAAI,CAAC,UAAU,EAAE,YAAY,CAAC,UAAU,EAAE,MAAM,CAAC;AACzF,SAAS,CAAC;AACV,KAAK;AACL,IAAI,OAAO,MAAM,IAAI,MAAM,CAAC,iBAAiB;AAC7C,UAAU;AACV,YAAY,GAAG,IAAI;AACnB,YAAY,IAAI,EAAE,sBAAsB;AACxC,SAAS;AACT,UAAU,IAAI,CAAC;AACf,CAAC;AACD;AACA,SAAS,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE;AAC3C,IAAI,IAAI,MAAM,EAAE;AAChB,QAAQ,OAAO;AACf,YAAY,IAAI,EAAE,KAAK,CAAC,IAAI;AAC5B,YAAY,WAAW,EAAE,KAAK,CAAC,aAAa,CAAC,IAAI,MAAM,CAAC,aAAa,CAAC;AACtE,YAAY,UAAU,EAAE,eAAe,CAAC,KAAK,CAAC,UAAU,EAAE,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC;AACpF,YAAY,IAAI,EAAE,CAAC,MAAM,IAAI,MAAM,CAAC,iBAAiB;AACrD,gBAAgB,KAAK,CAAC,IAAI,KAAK,qBAAqB;AACpD,gBAAgB,MAAM,CAAC,IAAI,KAAK,qBAAqB;AACrD,kBAAkB,qBAAqB;AACvC,kBAAkB,oBAAoB;AACtC,YAAY,GAAG,EAAE,KAAK,CAAC,GAAG;AAC1B,YAAY,KAAK,EAAE,mBAAmB,CAAC,KAAK,CAAC,KAAK,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC;AACzE,SAAS,CAAC;AACV,KAAK;AACL,IAAI,OAAO,MAAM,IAAI,MAAM,CAAC,iBAAiB;AAC7C,UAAU;AACV,YAAY,GAAG,KAAK;AACpB,YAAY,IAAI,EAAE,qBAAqB;AACvC,SAAS;AACT,UAAU,KAAK,CAAC;AAChB,CAAC;AACD;AACA,SAAS,iBAAiB,CAAC,KAAK,EAAE,MAAM,EAAE;AAC1C,IAAI,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,cAAc,KAAK;AAClD,QAAQ,MAAM,IAAI,GAAG,cAAc,CAAC;AACpC,QAAQ,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;AAClD,YAAY,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;AACzC,YAAY,IAAI,MAAM,IAAI,MAAM,CAAC,mBAAmB,EAAE;AACtD,gBAAgB,cAAc,CAAC,IAAI,CAAC,CAAC;AACrC,aAAa;AACb,YAAY,IAAI,MAAM;AACtB,gBAAgB,MAAM,CAAC,UAAU;AACjC,iBAAiB,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,EAAE;AAC/F,gBAAgB,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;AAClC,aAAa;AACb,iBAAiB,IAAI,aAAa,CAAC,cAAc,CAAC,IAAI,sBAAsB,CAAC,cAAc,CAAC,EAAE;AAC9F,gBAAgB,IAAI,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;AAC3E,aAAa;AACb,iBAAiB,IAAI,aAAa,CAAC,cAAc,CAAC,IAAI,sBAAsB,CAAC,cAAc,CAAC,EAAE;AAC9F,gBAAgB,IAAI,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;AAC3E,aAAa;AACb,iBAAiB,IAAI,cAAc,CAAC,cAAc,CAAC,IAAI,uBAAuB,CAAC,cAAc,CAAC,EAAE;AAChG,gBAAgB,IAAI,CAAC,IAAI,CAAC,GAAG,UAAU,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;AAC5E,aAAa;AACb,iBAAiB,IAAI,eAAe,CAAC,cAAc,CAAC,IAAI,wBAAwB,CAAC,cAAc,CAAC,EAAE;AAClG,gBAAgB,IAAI,CAAC,IAAI,CAAC,GAAG,WAAW,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;AAC7E,aAAa;AACb,iBAAiB,IAAI,kBAAkB,CAAC,cAAc,CAAC,IAAI,2BAA2B,CAAC,cAAc,CAAC,EAAE;AACxG,gBAAgB,IAAI,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;AAChF,aAAa;AACb,iBAAiB,IAAI,kBAAkB,CAAC,cAAc,CAAC,IAAI,2BAA2B,CAAC,cAAc,CAAC,EAAE;AACxG,gBAAgB,IAAI,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;AAChF,aAAa;AACb,iBAAiB,IAAI,kBAAkB,CAAC,cAAc,CAAC,EAAE;AACzD,gBAAgB,IAAI,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC,cAAc,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;AACxE,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK,EAAE,EAAE,CAAC,CAAC;AACX,CAAC;AACD;AACA,SAAS,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE;AACtC,IAAI,aAAa,EAAE,CAAC;AACpB,IAAI,MAAM,GAAG,GAAG;AAChB,QAAQ,IAAI,EAAEK,YAAI,CAAC,QAAQ;AAC3B,QAAQ,WAAW,EAAE,iBAAiB,CAAC,KAAK,EAAE;AAC9C,YAAY,mBAAmB,EAAE,IAAI;AACrC,YAAY,qBAAqB,EAAE,KAAK;AACxC,YAAY,eAAe,EAAE,KAAK;AAClC,YAAY,mBAAmB,EAAE,KAAK;AACtC,YAAY,GAAG,MAAM;AACrB,SAAS,CAAC;AACV,KAAK,CAAC;AACN,IAAI,IAAI,MAAM,CAAC;AACf,IAAI,IAAI,MAAM,IAAI,MAAM,CAAC,mBAAmB,EAAE;AAC9C,QAAQ,MAAM,GAAG,iBAAiB,CAAC,GAAG,CAAC,CAAC;AACxC,KAAK;AACL,SAAS;AACT,QAAQ,MAAM,GAAG,GAAG,CAAC;AACrB,KAAK;AACL,IAAI,aAAa,EAAE,CAAC;AACpB,IAAI,OAAO,MAAM,CAAC;AAClB,CAAC;AACD,SAAS,iBAAiB,CAAC,KAAK,EAAE,MAAM,EAAE;AAC1C,IAAI,aAAa,EAAE,CAAC;AACpB,IAAI,MAAM,QAAQ,GAAG,KAAK;AAC1B,SAAS,GAAG,CAAC,IAAI,IAAI;AACrB,QAAQ,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;AACjC,YAAY,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;AACvC,SAAS;AACT,QAAQ,IAAIE,gBAAQ,CAAC,IAAI,CAAC,EAAE;AAC5B,YAAY,OAAOC,aAAK,CAACC,+BAAyB,CAAC,IAAI,CAAC,CAAC,CAAC;AAC1D,SAAS;AACT,aAAa,IAAI,aAAa,CAAC,IAAI,CAAC,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;AAC7D,YAAY,OAAOD,aAAK,CAAC,IAAI,CAAC,CAAC;AAC/B,SAAS;AACT,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK,CAAC;AACN,SAAS,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,WAAW,CAAC;AACpC,SAAS,MAAM,CAAC,CAAC,IAAI,EAAE,MAAM,GAAG,EAAE,KAAK,CAAC,GAAG,IAAI,EAAE,GAAG,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC;AACjE;AACA,IAAI,IAAI,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,KAAK;AAC9E,QAAQ,IAAI,CAAC,cAAc;AAC3B,aAAa,MAAM,CAAC,EAAE,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;AAC7C,aAAa,OAAO,CAAC,EAAE,IAAI;AAC3B,YAAY,GAAG,CAAC,EAAE,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;AACnD,SAAS,CAAC,CAAC;AACX,QAAQ,OAAO,GAAG,CAAC;AACnB,KAAK,EAAE;AACP,QAAQ,KAAK,EAAE,IAAI;AACnB,QAAQ,QAAQ,EAAE,IAAI;AACtB,QAAQ,YAAY,EAAE,IAAI;AAC1B,KAAK,CAAC,CAAC;AACP,IAAI,MAAM,WAAW,GAAG,iBAAiB,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;AAC5D,IAAI,MAAM,QAAQ,GAAG,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;AAC9C,IAAI,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC/B,QAAQ,QAAQ,CAAC,IAAI,CAAC,OAAO,MAAM,CAAC,IAAI,KAAK,UAAU,GAAG,MAAM,CAAC,IAAI,GAAG,SAAS,CAAC,CAAC;AACnF,KAAK;AACL,IAAI,IAAI,MAAM,IAAI,MAAM,CAAC,mBAAmB,EAAE;AAC9C,QAAQ,MAAM,SAAS,GAAG,SAAS,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,OAAO,CAAC,CAAC;AAChG,QAAQ,MAAM,YAAY,GAAG,SAAS,CAAC,QAAQ,GAAG,SAAS,CAAC,QAAQ,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,UAAU,CAAC,CAAC;AAC5G,QAAQ,MAAM,gBAAgB,GAAG,SAAS,CAAC,YAAY,GAAG,SAAS,CAAC,YAAY,GAAG,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,KAAK,cAAc,CAAC,CAAC;AAC5H,QAAQ,SAAS,GAAG;AACpB,YAAY,KAAK,EAAE,SAAS;AAC5B,YAAY,QAAQ,EAAE,YAAY;AAClC,YAAY,YAAY,EAAE,gBAAgB;AAC1C,SAAS,CAAC;AACV,KAAK;AACL,IAAI,MAAM,gBAAgB,GAAGE,4BAAsB,CAAC,SAAS,EAAE;AAC/D,QAAQ,KAAK,EAAE,MAAM,CAAC,qBAAqB;AAC3C,KAAK,CAAC,CAAC;AACP,IAAI,IAAI,CAAC,gBAAgB,EAAE;AAC3B,QAAQ,OAAO,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;AAC1C,KAAK;AACL,IAAI,OAAO,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,EAAEF,aAAK,CAAC,gBAAgB,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;AACnF;;AC3xBA,MAAM,eAAe,GAAG,CAAC,MAAM,EAAE,OAAO,EAAE,UAAU,EAAE,WAAW,CAAC,CAAC;AACnE,SAAS,mBAAmB,CAAC,MAAM,EAAE;AACrC,IAAI,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,EAAE,CAAC;AACxC,IAAI,OAAO,aAAa,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,aAAa,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;AACvF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,iBAAiB,CAAC;AAC/B,IAAI,QAAQ,GAAG;AACf,QAAQ,OAAO,cAAc,CAAC;AAC9B,KAAK;AACL,IAAI,MAAM,OAAO,CAAC,OAAO,EAAE,OAAO,EAAE;AACpC,QAAQ,IAAIG,iBAAW,CAAC,OAAO,CAAC,EAAE;AAClC,YAAY,IAAI,eAAe,CAAC,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE;AAChF,gBAAgB,MAAM,kBAAkB,GAAGC,eAAU,CAAC,OAAO,CAAC,GAAG,OAAO,GAAGC,YAAO,CAAC,OAAO,CAAC,GAAG,IAAIC,WAAU,EAAE,EAAE,OAAO,CAAC,CAAC;AACzH,gBAAgB,OAAOC,kBAAU,CAAC,kBAAkB,CAAC,CAAC;AACtD,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL,IAAI,WAAW,CAAC,OAAO,EAAE,OAAO,EAAE;AAClC,QAAQ,IAAIJ,iBAAW,CAAC,OAAO,CAAC,EAAE;AAClC,YAAY,IAAI,eAAe,CAAC,IAAI,CAAC,SAAS,IAAI,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE;AAChF,gBAAgB,MAAM,kBAAkB,GAAGC,eAAU,CAAC,OAAO,CAAC,GAAG,OAAO,GAAGC,YAAO,CAAC,OAAO,CAAC,GAAG,IAAIC,WAAU,EAAE,EAAE,OAAO,CAAC,CAAC;AACzH,gBAAgB,OAAOE,sBAAc,CAAC,kBAAkB,CAAC,CAAC;AAC1D,aAAa;AACb,SAAS;AACT,QAAQ,OAAO,KAAK,CAAC;AACrB,KAAK;AACL,IAAI,MAAM,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE;AACjC,QAAQ,MAAM,kBAAkB,GAAGJ,eAAU,CAAC,OAAO,CAAC,GAAG,OAAO,GAAGC,YAAO,CAAC,OAAO,CAAC,GAAG,IAAIC,WAAU,EAAE,EAAE,OAAO,CAAC,CAAC;AACjH,QAAQ,MAAM,MAAM,GAAG,MAAMG,gBAAQ,CAAC,kBAAkB,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;AAChF,QAAQ,OAAO,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;AAChE,KAAK;AACL,IAAI,QAAQ,CAAC,OAAO,EAAE,OAAO,EAAE;AAC/B,QAAQ,MAAM,kBAAkB,GAAGL,eAAU,CAAC,OAAO,CAAC,GAAG,OAAO,GAAGC,YAAO,CAAC,OAAO,CAAC,GAAG,IAAIC,WAAU,EAAE,EAAE,OAAO,CAAC,CAAC;AACjH,QAAQ,MAAM,MAAM,GAAGI,oBAAY,CAAC,kBAAkB,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC,CAAC;AAC9E,QAAQ,OAAO,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC;AAChE,KAAK;AACL,IAAI,iBAAiB,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE;AAChD,QAAQ,IAAI,CAAC,OAAO,CAAC,iBAAiB,IAAI,mBAAmB,CAAC,MAAM,CAAC,EAAE;AACvE,YAAY,MAAM,QAAQ,GAAGC,qBAAa,CAAC,OAAO,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC;AACjE,YAAY,MAAM,qBAAqB,GAAG,QAAQ,CAAC,WAAW;AAC9D,iBAAiB,MAAM,CAAC,CAAC,IAAI,CAACC,kCAA0B,CAAC,CAAC,CAAC,CAAC;AAC5D,iBAAiB,GAAG,CAAC,UAAU,KAAK;AACpC,gBAAgB,IAAI,EAAEf,YAAI,CAAC,QAAQ;AACnC,gBAAgB,WAAW,EAAE,CAAC,UAAU,CAAC;AACzC,aAAa,CAAC,CAAC,CAAC;AAChB,YAAY,MAAM,cAAc,GAAG,aAAa,CAAC,qBAAqB,EAAE,EAAE,mBAAmB,EAAE,KAAK,EAAE,CAAC,CAAC;AACxG,YAAY,MAAM,qBAAqB,GAAG,QAAQ,CAAC,WAAW,CAAC,MAAM,CAACe,kCAA0B,CAAC,CAAC;AAClG,YAAY,OAAO;AACnB,gBAAgB,QAAQ,EAAE,OAAO;AACjC,gBAAgB,QAAQ,EAAE;AAC1B,oBAAoB,GAAG,cAAc;AACrC,oBAAoB,WAAW,EAAE,CAAC,GAAG,cAAc,CAAC,WAAW,EAAE,GAAG,qBAAqB,CAAC;AAC1F,iBAAiB;AACjB,aAAa,CAAC;AACd,SAAS;AACT,QAAQ,OAAOC,qBAAe,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;AACzD,KAAK;AACL;;;;"}