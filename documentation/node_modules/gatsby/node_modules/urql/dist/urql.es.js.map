{"version":3,"file":"urql.es.js","sources":["../src/hooks/useMutation.ts","../src/hooks/useSource.ts","../src/hooks/useRequest.ts","../src/hooks/useQuery.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/components/Query.ts","../src/components/Subscription.ts","../src/context.ts","../src/hooks/constants.ts"],"sourcesContent":["import { DocumentNode } from 'graphql';\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { pipe, toPromise } from 'wonka';\n\nimport {\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation;\n}\n\nexport type UseMutationResponse<T, V> = [\n  UseMutationState<T>,\n  (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>\n];\n\nexport function useMutation<T = any, V = object>(\n  query: DocumentNode | string\n): UseMutationResponse<T, V> {\n  const isMounted = useRef(true);\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<T>>(initialState);\n\n  const executeMutation = useCallback(\n    (variables?: V, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      return pipe(\n        client.executeMutation(\n          createRequest(query, variables as any),\n          context || {}\n        ),\n        toPromise\n      ).then(result => {\n        if (isMounted.current) {\n          setState({\n            fetching: false,\n            stale: !!result.stale,\n            data: result.data,\n            error: result.error,\n            extensions: result.extensions,\n            operation: result.operation,\n          });\n        }\n        return result;\n      });\n    },\n    [client, query, setState]\n  );\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { useMemo, useEffect, useState } from 'react';\n\nimport {\n  Source,\n  fromValue,\n  makeSubject,\n  pipe,\n  map,\n  concat,\n  onPush,\n  publish,\n  subscribe,\n} from 'wonka';\n\nimport { useClient } from '../context';\n\nlet currentInit = false;\n\nexport function useSource<T>(source: Source<T>, init: T): T {\n  const [state, setState] = useState(() => {\n    currentInit = true;\n    let initialValue = init;\n\n    pipe(\n      source,\n      onPush(value => {\n        initialValue = value;\n      }),\n      publish\n    ).unsubscribe();\n\n    currentInit = false;\n    return initialValue;\n  });\n\n  useEffect(() => {\n    return pipe(\n      source,\n      subscribe(value => {\n        if (!currentInit) {\n          setState(value);\n        }\n      })\n    ).unsubscribe as () => void;\n  }, [source]);\n\n  return state;\n}\n\nexport function useBehaviourSubject<T>(value: T) {\n  const client = useClient();\n\n  const state = useMemo((): [Source<T>, (value: T) => void] => {\n    let prevValue = value;\n\n    const subject = makeSubject<T>();\n    const prevValue$ = pipe(\n      fromValue(value),\n      map(() => prevValue)\n    );\n\n    // This turns the subject into a behaviour subject that returns\n    // the last known value (or the initial value) synchronously\n    const source = concat([prevValue$, subject.source]);\n\n    const next = (value: T) => {\n      // We can use the latest known value to also deduplicate next calls.\n      if (value !== prevValue) {\n        subject.next((prevValue = value));\n      }\n    };\n\n    return [source, next];\n  }, []);\n\n  // NOTE: This is a special case for client-side suspense.\n  // We can't trigger suspense inside an effect but only in the render function.\n  // So we \"deopt\" to not using an effect if the client is in suspense-mode.\n  useEffect(() => {\n    if (!client.suspense) state[1](value);\n  }, [state, value]);\n\n  if (client.suspense) state[1](value);\n\n  return state;\n}\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { GraphQLRequest, createRequest } from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport function useRequest(\n  query: string | DocumentNode,\n  variables?: any\n): GraphQLRequest {\n  const prev = useRef<undefined | GraphQLRequest>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport {\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource, useBehaviourSubject } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<V> {\n  query: string | DocumentNode;\n  variables?: V;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation;\n}\n\nexport type UseQueryResponse<T> = [\n  UseQueryState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport function useQuery<T = any, V = object>(\n  args: UseQueryArgs<V>\n): UseQueryResponse<T> {\n  const client = useClient();\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeQuery(request, {\n        requestPolicy: args.requestPolicy,\n        pollInterval: args.pollInterval,\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const [query$$, update] = useBehaviourSubject(\n    useMemo(() => (args.pause ? null : makeQuery$()), [args.pause, makeQuery$])\n  );\n\n  const state = useSource(\n    useMemo(() => {\n      return pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false, stale: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions, operation }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                operation,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result, partial) => ({\n            ...result,\n            ...partial,\n          }),\n          initialState\n        )\n      );\n    }, [query$$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeQuery$(opts)),\n    [update, makeQuery$]\n  );\n\n  return [state, executeQuery];\n}\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport { CombinedError, OperationContext, Operation } from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource, useBehaviourSubject } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<V> {\n  query: DocumentNode | string;\n  variables?: V;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation;\n}\n\nexport type UseSubscriptionResponse<T> = [\n  UseSubscriptionState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport function useSubscription<T = any, R = T, V = object>(\n  args: UseSubscriptionArgs<V>,\n  handler?: SubscriptionHandler<T, R>\n): UseSubscriptionResponse<R> {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription(request, { ...args.context, ...opts });\n    },\n    [client, request, args.context]\n  );\n\n  const [subscription$$, update] = useBehaviourSubject(\n    useMemo(() => (args.pause ? null : makeSubscription$()), [\n      args.pause,\n      makeSubscription$,\n    ])\n  );\n\n  const state = useSource(\n    useMemo(() => {\n      return pipe(\n        subscription$$,\n        switchMap(subscription$ => {\n          if (!subscription$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              subscription$,\n              map(({ stale, data, error, extensions, operation }) => ({\n                fetching: true,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n                operation,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan((result, partial: any) => {\n          const { current: handler } = handlerRef;\n          // If a handler has been passed, it's used to merge new data in\n          const data =\n            partial.data !== undefined\n              ? typeof handler === 'function'\n                ? handler(result.data, partial.data)\n                : partial.data\n              : result.data;\n          return { ...result, ...partial, data };\n        }, initialState)\n      );\n    }, [subscription$$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  return [state, executeSubscription];\n}\n","import { ReactElement } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { OperationResult, OperationContext } from '@urql/core';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<T, V> {\n  query: DocumentNode | string;\n  children: (arg: MutationState<T, V>) => ReactElement<any>;\n}\n\nexport interface MutationState<T, V> extends UseMutationState<T> {\n  executeMutation: (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>;\n}\n\nexport function Mutation<T = any, V = any>(\n  props: MutationProps<T, V>\n): ReactElement<any> {\n  const [state, executeMutation] = useMutation<T, V>(props.query);\n  return props.children({ ...state, executeMutation });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<T, V> extends UseQueryArgs<V> {\n  children: (arg: QueryState<T>) => ReactElement<any>;\n}\n\nexport interface QueryState<T> extends UseQueryState<T> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<T = any, V = any>(\n  props: QueryProps<T, V>\n): ReactElement<any> {\n  const [state, executeQuery] = useQuery<T, V>(props);\n  return props.children({ ...state, executeQuery });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<T, R, V> extends UseSubscriptionArgs<V> {\n  handler?: SubscriptionHandler<T, R>;\n  children: (arg: SubscriptionState<R>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<T> extends UseSubscriptionState<T> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<T = any, R = T, V = any>(\n  props: SubscriptionProps<T, R, V>\n): ReactElement<any> {\n  const [state, executeSubscription] = useSubscription<T, R, V>(\n    props,\n    props.handler\n  );\n  return props.children({ ...state, executeSubscription });\n}\n","import { createContext, useContext } from 'react';\nimport { Client, createClient } from '@urql/core';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n"],"names":["fetching","stale","data","error","extensions","operation","isMounted","useClient","client","useState","_ref2","useSource","publish","initialValue","const","prevValue$","next","value","state","suspense","useMemo","prev","current","query","variables","fromValue","makeQuery$","useRequest","requestPolicy","useCallback","executeQuery","opts","useBehaviourSubject","args","scan","query$$","initialState","update","ref","subscription$","makeSubscription$","context","subscription$$","Context","Provider","hasWarnedAboutDefault","currentInit","undefined"],"mappings":";;;;;;;;;;;;;;;;;;;;QAqDYA;QACAC;QACAC;QACAC,mBAJOC;QAKPA,kBAAkBC;;;;;;;;8BAtBtBC,SAASC,aACTC,MAAMC;;;;;uBASND;;WAsBGE;;;;;SC9CcC;;;;;;;;IASnBC;;MALFC;;;;;;;;;;;AA6BFC;EAAAA;QAIQC;;2BASAC,kBAAQC,sCAEH;;;;;;;aAYiB;;MAC1BC;;QAEAV,OAAOW;;;;;;;ACzEX,SAAOC;;;QAGDC;;MAGFA,YAAAC;;;MAGAC,OAAOC;;;;;AC0ED;;;;;;SAhBS;eAFiD;;;;;;;;;AAP/C;;WAAyCC;MAAzCzB;;;;;IAECA;YAeH;;IAfGA;;;;;;4BAvBhB0B,UAAUC,wCAGVC,aAAaC;kBACDC;qBAETC,KAJEH;MAORpB;YAGuBwB;8BACTJ,mDAAoCK;;oCAG/Cf,mCA0BAgB;WAQAC,WACJC;QAIIN,2BAEHO;6BAGIN;;;;;;sGCjC6DO;SAEjD;eAFiD;;;;;;;;;AAPxC;;;;;;;IAENtC;YAeH;mBAACuC;IAfEvC;;;;;;;QAsBRE;;;;;MA3CRsC,SAIHhC,mBAKCyB;;EATEO;EAIHhC;;8BAIciC;EACbR;;;;;WA2CES;;oCAUCX;;;;AC3FA;EAAA,4BAAOR,gBACFe;;;;;;ACNL;EAAA,mCACKA;;;;;;ACML;EAAA,yDAIKA;;;;;;sCCnBDK,UACAC,uBAGTC,yBPOAC;;;;;;;;;;;;;;;;AOXSH;;AACAC;;AAGTC;;;;IAUAA;;;;;;;ECpBF7C;EACAC,YAAO8C;EACP5C;EACAD;EACAE;;;ARaE0C,eAAc;;"}