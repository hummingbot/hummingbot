"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.fixedPagePath = fixedPagePath;
exports.readPageData = readPageData;
exports.removePageData = removePageData;
exports.pageDataExists = pageDataExists;
exports.writePageData = writePageData;
exports.isFlushEnqueued = isFlushEnqueued;
exports.flush = flush;
exports.enqueueFlush = enqueueFlush;
exports.handleStalePageData = handleStalePageData;

var _fs = require("@nodelib/fs.walk");

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _reporter = _interopRequireDefault(require("gatsby-cli/lib/reporter"));

var _path = _interopRequireDefault(require("path"));

var _websocketManager = require("./websocket-manager");

var _webpackStatus = require("./webpack-status");

var _redux = require("../redux");

function fixedPagePath(pagePath) {
  return pagePath === `/` ? `index` : pagePath;
}

function getFilePath(publicDir, pagePath) {
  return _path.default.join(publicDir, `page-data`, fixedPagePath(pagePath), `page-data.json`);
}

async function readPageData(publicDir, pagePath) {
  const filePath = getFilePath(publicDir, pagePath);
  const rawPageData = await _fsExtra.default.readFile(filePath, `utf-8`);
  return JSON.parse(rawPageData);
}

async function removePageData(publicDir, pagePath) {
  const filePath = getFilePath(publicDir, pagePath);

  if (_fsExtra.default.existsSync(filePath)) {
    return await _fsExtra.default.remove(filePath);
  }

  return Promise.resolve();
}

function pageDataExists(publicDir, pagePath) {
  return _fsExtra.default.existsSync(getFilePath(publicDir, pagePath));
}

async function writePageData(publicDir, {
  componentChunkName,
  matchPath,
  path: pagePath,
  staticQueryHashes
}) {
  const inputFilePath = _path.default.join(publicDir, `..`, `.cache`, `json`, `${pagePath.replace(/\//g, `_`)}.json`);

  const outputFilePath = getFilePath(publicDir, pagePath);
  const result = await _fsExtra.default.readJSON(inputFilePath);
  const body = {
    componentChunkName,
    path: pagePath,
    matchPath,
    result,
    staticQueryHashes
  };
  const bodyStr = JSON.stringify(body); // transform asset size to kB (from bytes) to fit 64 bit to numbers

  const pageDataSize = Buffer.byteLength(bodyStr) / 1000;

  _redux.store.dispatch({
    type: `ADD_PAGE_DATA_STATS`,
    payload: {
      filePath: outputFilePath,
      size: pageDataSize
    }
  });

  await _fsExtra.default.outputFile(outputFilePath, bodyStr);
  return body;
}

let isFlushPending = false;
let isFlushing = false;

function isFlushEnqueued() {
  return isFlushPending;
}

async function flush() {
  if (isFlushing) {
    // We're already in the middle of a flush
    return;
  }

  isFlushPending = false;
  isFlushing = true;

  const {
    pendingPageDataWrites,
    components,
    pages,
    program,
    staticQueriesByTemplate
  } = _redux.store.getState();

  const {
    pagePaths,
    templatePaths
  } = pendingPageDataWrites;
  const pagesToWrite = Array.from(templatePaths).reduce((set, componentPath) => {
    const templateComponent = components.get(componentPath);

    if (templateComponent) {
      templateComponent.pages.forEach(set.add.bind(set));
    }

    return set;
  }, new Set(pagePaths.values()));

  for (const pagePath of pagesToWrite) {
    const page = pages.get(pagePath); // It's a gloomy day in Bombay, let me tell you a short story...
    // Once upon a time, writing page-data.json files were atomic
    // After this change (#24808), they are not and this means that
    // between adding a pending write for a page and actually flushing
    // them, a page might not exist anymore щ（ﾟДﾟщ）
    // This is why we need this check

    if (page) {
      var _program$_;

      const staticQueryHashes = staticQueriesByTemplate.get(page.componentPath) || [];
      const result = await writePageData(_path.default.join(program.directory, `public`), { ...page,
        staticQueryHashes
      });

      if ((program === null || program === void 0 ? void 0 : (_program$_ = program._) === null || _program$_ === void 0 ? void 0 : _program$_[0]) === `develop`) {
        _websocketManager.websocketManager.emitPageData({
          id: pagePath,
          result
        });
      }
    }
  }

  _redux.store.dispatch({
    type: `CLEAR_PENDING_PAGE_DATA_WRITES`
  });

  isFlushing = false;
  return;
}

function enqueueFlush() {
  if ((0, _webpackStatus.isWebpackStatusPending)()) {
    isFlushPending = true;
  } else {
    flush();
  }
}

async function handleStalePageData() {
  if (!(await _fsExtra.default.pathExists(`public/page-data`))) {
    return;
  } // public directory might have stale page-data files from previous builds
  // we get the list of those and compare against expected page-data files
  // and remove ones that shouldn't be there anymore


  const activity = _reporter.default.activityTimer(`Cleaning up stale page-data`);

  activity.start();
  const pageDataFilesFromPreviousBuilds = await new Promise((resolve, reject) => {
    const results = new Set();
    const stream = (0, _fs.walkStream)(`public/page-data`);
    stream.on(`data`, data => {
      if (data.name === `page-data.json`) {
        results.add(data.path);
      }
    });
    stream.on(`error`, e => {
      reject(e);
    });
    stream.on(`end`, () => resolve(results));
  });
  const expectedPageDataFiles = new Set();

  _redux.store.getState().pages.forEach(page => {
    expectedPageDataFiles.add(getFilePath(`public`, page.path));
  });

  const deletionPromises = [];
  pageDataFilesFromPreviousBuilds.forEach(pageDataFilePath => {
    if (!expectedPageDataFiles.has(pageDataFilePath)) {
      deletionPromises.push(_fsExtra.default.remove(pageDataFilePath));
    }
  });
  await Promise.all(deletionPromises);
  activity.end();
}
//# sourceMappingURL=page-data.js.map