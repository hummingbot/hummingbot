{"version":3,"sources":["../../src/query/queue.ts"],"names":["createBaseOptions","concurrent","Number","process","env","GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY","store","createBuildQueue","graphqlRunner","runnerOptions","GraphQLRunner","queueOptions","job","activity","callback","span","then","result","catch","Queue","createDevelopQueue","getRunner","priority","cb","id","websocketManager","activePaths","has","merge","_oldTask","newTask","queryJob","isPage","emitStaticQueryData","error","createAppropriateQueue","NODE_ENV","processBatch","queue","jobs","length","Promise","resolve","reject","taskFinishCallback","gc","off","taskFailedCallback","drainCallback","tick","on","err","forEach","push"],"mappings":"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","sourcesContent":["import Queue from \"better-queue\"\nimport { store } from \"../redux\"\nimport { memoryStoreWithPriorityBuckets } from \"../query/better-queue-custom-store\"\nimport { queryRunner } from \"../query/query-runner\"\nimport { websocketManager } from \"../utils/websocket-manager\"\nimport { GraphQLRunner, IGraphQLRunnerOptions } from \"./graphql-runner\"\nimport BetterQueue from \"better-queue\"\nimport { ProgressActivityTracker } from \"../..\"\n\nexport type Task = any\ntype TaskResult = any\n\nconst createBaseOptions = (): Pick<\n  BetterQueue.QueueOptions<Task, TaskResult>,\n  \"concurrent\" | \"store\"\n> => {\n  return {\n    concurrent: Number(process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY) || 4,\n    store: memoryStoreWithPriorityBuckets<Task>(),\n  }\n}\n\nconst createBuildQueue = (\n  graphqlRunner: GraphQLRunner,\n  runnerOptions: IGraphQLRunnerOptions = {}\n): Queue => {\n  if (!graphqlRunner) {\n    graphqlRunner = new GraphQLRunner(store, runnerOptions)\n  }\n\n  const queueOptions: BetterQueue.QueueOptions<Task, TaskResult> = {\n    ...createBaseOptions(),\n    process: ({ job, activity }, callback): void => {\n      queryRunner(graphqlRunner, job, activity?.span)\n        .then(result => callback(null, result))\n        .catch(callback)\n    },\n  }\n  return new Queue(queueOptions)\n}\n\nconst createDevelopQueue = (getRunner: () => GraphQLRunner): Queue => {\n  const queueOptions: BetterQueue.QueueOptions<Task, TaskResult> = {\n    ...createBaseOptions(),\n    priority: ({ job }, cb): void => {\n      if (job.id && websocketManager.activePaths.has(job.id)) {\n        cb(null, 10)\n      } else {\n        cb(null, 1)\n      }\n    },\n    merge: (\n      _oldTask: Task,\n      newTask: Task,\n      cb: (err?: unknown, newTask?: Task) => void\n    ): void => {\n      cb(null, newTask)\n    },\n    process: ({ job: queryJob, activity }, callback): void => {\n      queryRunner(getRunner(), queryJob, activity?.span).then(\n        result => {\n          if (!queryJob.isPage) {\n            websocketManager.emitStaticQueryData({\n              result,\n              id: queryJob.id,\n            })\n          }\n\n          callback(null, result)\n        },\n        error => callback(error)\n      )\n    },\n  }\n\n  return new Queue(queueOptions)\n}\n\nconst createAppropriateQueue = (\n  graphqlRunner: GraphQLRunner,\n  runnerOptions: IGraphQLRunnerOptions = {}\n): Queue => {\n  if (process.env.NODE_ENV === `production`) {\n    return createBuildQueue(graphqlRunner, runnerOptions)\n  }\n  if (!graphqlRunner) {\n    graphqlRunner = new GraphQLRunner(store, runnerOptions)\n  }\n  return createDevelopQueue(() => graphqlRunner)\n}\n\n/**\n * Returns a promise that pushes jobs onto queue and resolves onces\n * they're all finished processing (or rejects if one or more jobs\n * fail)\n * Note: queue is reused in develop so make sure to thoroughly cleanup hooks\n */\nconst processBatch = async (\n  queue: Queue<Task, TaskResult>,\n  jobs: Array<Task>,\n  activity: ProgressActivityTracker\n): Promise<unknown> => {\n  if (jobs.length === 0) {\n    return Promise.resolve()\n  }\n\n  return new Promise((resolve, reject) => {\n    let taskFinishCallback\n\n    const gc = (): void => {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      queue.off(`task_failed`, taskFailedCallback)\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      queue.off(`drain`, drainCallback)\n      if (taskFinishCallback) {\n        queue.off(`task_finish`, taskFinishCallback)\n      }\n      // We don't want to allow the variable to be null any other time,\n      // just when marking it as eligible for garbage collection.\n      // @ts-ignore\n      queue = null\n    }\n\n    if (activity.tick) {\n      taskFinishCallback = (): unknown => activity.tick()\n      queue.on(`task_finish`, taskFinishCallback)\n    }\n\n    const taskFailedCallback = (...err: Array<unknown>): void => {\n      gc()\n      reject(err)\n    }\n\n    const drainCallback = (): void => {\n      gc()\n      resolve()\n    }\n\n    queue\n      // Note: the first arg is the path, the second the error\n      .on(`task_failed`, taskFailedCallback)\n      // Note: `drain` fires when all tasks _finish_\n      //       `empty` fires when queue is empty (but tasks are still running)\n      .on(`drain`, drainCallback)\n\n    jobs.forEach(job =>\n      queue.push({\n        job,\n        activity,\n      })\n    )\n  })\n}\n\nexport {\n  createBuildQueue,\n  createDevelopQueue,\n  processBatch,\n  createAppropriateQueue,\n}\n"],"file":"queue.js"}