{"version":3,"sources":["../../src/redux/run-fast-filters.ts"],"names":["createFilterCacheKey","typeNames","filter","filterStep","comparator","paths","push","path","type","q","nestedQuery","query","join","prepareQueryArgs","filterFields","filters","Object","keys","forEach","key","value","_","isPlainObject","Error","applyFastFilters","nodeTypeNames","filtersCache","nodesPerValueArrs","getBucketsForFilters","length","sort","a","b","pop","result","every","filterCacheKey","getBucketsForQueryFilter","collectBucketForElemMatch","undefined","filterPath","filterValue","has","nodesPerValue","targetValue","f","nodesByValue","runFastFiltersAndSort","args","queryArgs","resolvedFields","firstOnly","stats","convertAndApplyFastFilters","sortNodes","filterStats","filterToStats","comparatorPath","comparatorsUsed","set","get","uniqueFilterPaths","add","totalNonSingleFilters","filterCache","cache","meta","orderedByCounter","slice","totalIndexHits","totalSiftHits","concat","nodes","dottedFields","dottedFieldKeys","sortFields","fields","map","field","some","startsWith","sortFns","v","sortOrder","order","toLowerCase","sortField","uniqueSorts","orderBy"],"mappings":"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","sourcesContent":["import { IGatsbyNode } from \"./types\"\nimport { GatsbyGraphQLType } from \"../..\"\nimport { prepareRegex } from \"../utils/prepare-regex\"\nimport { makeRe } from \"micromatch\"\nimport { getValueAt } from \"../utils/get-value-at\"\nimport _ from \"lodash\"\nimport {\n  DbQuery,\n  IDbQueryQuery,\n  IDbQueryElemMatch,\n  objectToDottedField,\n  createDbQueriesFromObject,\n  prefixResolvedFields,\n} from \"../db/common/query\"\nimport {\n  FilterOp,\n  FilterCacheKey,\n  FiltersCache,\n  FilterValueNullable,\n  ensureEmptyFilterCache,\n  ensureIndexByQuery,\n  ensureIndexByElemMatch,\n  getNodesFromCacheByValue,\n  intersectNodesByCounter,\n  IFilterCache,\n} from \"./nodes\"\nimport { IGraphQLRunnerStats } from \"../query/types\"\n\n// The value is an object with arbitrary keys that are either filter values or,\n// recursively, an object with the same struct. Ie. `{a: {a: {a: 2}}}`\ninterface IInputQuery {\n  [key: string]: FilterValueNullable | IInputQuery\n}\n// Similar to IInputQuery except the comparator leaf nodes will have their\n// key prefixed with `$` and their value, in some cases, normalized.\ninterface IPreparedQueryArg {\n  [key: string]: FilterValueNullable | IPreparedQueryArg\n}\n\ninterface IRunFilterArg {\n  gqlType: GatsbyGraphQLType\n  queryArgs: {\n    filter: Array<IInputQuery> | undefined\n    sort:\n      | { fields: Array<string>; order: Array<boolean | \"asc\" | \"desc\"> }\n      | undefined\n  }\n  firstOnly: boolean\n  resolvedFields: Record<string, any>\n  nodeTypeNames: Array<string>\n  filtersCache: FiltersCache\n  stats: IGraphQLRunnerStats\n}\n\n/**\n * Creates a key for one filterCache inside FiltersCache\n */\nfunction createFilterCacheKey(\n  typeNames: Array<string>,\n  filter: DbQuery | null\n): FilterCacheKey {\n  // Note: while `elemMatch` is a special case, in the key it's just `elemMatch`\n  // (This function is future proof for elemMatch support, won't receive it yet)\n  let filterStep = filter\n  let comparator = ``\n  const paths: Array<string> = []\n  while (filterStep) {\n    paths.push(...filterStep.path)\n    if (filterStep.type === `elemMatch`) {\n      const q: IDbQueryElemMatch = filterStep\n      filterStep = q.nestedQuery\n      // Make distinction between filtering `a.elemMatch.b.eq` and `a.b.eq`\n      // In practice this is unlikely to be an issue, but it might\n      paths.push(`elemMatch`)\n    } else {\n      const q: IDbQueryQuery = filterStep\n      comparator = q.query.comparator\n      break\n    }\n  }\n\n  // Note: the separators (`,` and `/`) are arbitrary but must be different\n  return typeNames.join(`,`) + `/` + paths.join(`,`) + `/` + comparator\n}\n\nfunction prepareQueryArgs(\n  filterFields: Array<IInputQuery> | IInputQuery = {}\n): IPreparedQueryArg {\n  const filters = {}\n  Object.keys(filterFields).forEach(key => {\n    const value = filterFields[key]\n    if (_.isPlainObject(value)) {\n      filters[key === `elemMatch` ? `$elemMatch` : key] = prepareQueryArgs(\n        value as IInputQuery\n      )\n    } else {\n      switch (key) {\n        case `regex`:\n          if (typeof value !== `string`) {\n            throw new Error(\n              `The $regex comparator is expecting the regex as a string, not an actual regex or anything else`\n            )\n          }\n          filters[`$regex`] = prepareRegex(value)\n          break\n        case `glob`:\n          filters[`$regex`] = makeRe(value)\n          break\n        default:\n          filters[`$${key}`] = value\n      }\n    }\n  })\n  return filters\n}\n\n/**\n * Given the path of a set of filters, return the sets of nodes that pass the\n * filter.\n * Only nodes of given node types will be considered\n * A fast index is created if one doesn't exist yet so cold call is slower.\n *\n * Note: Not a public API. Exported for tests.\n */\nexport function applyFastFilters(\n  filters: Array<DbQuery>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache\n): Array<IGatsbyNode> | null {\n  if (!filtersCache) {\n    // If no filter cache is passed on, explicitly don't use one\n    return null\n  }\n\n  const nodesPerValueArrs = getBucketsForFilters(\n    filters,\n    nodeTypeNames,\n    filtersCache\n  )\n\n  if (!nodesPerValueArrs) {\n    return null\n  }\n\n  if (nodesPerValueArrs.length === 0) {\n    return []\n  } else {\n    // Put smallest last (we'll pop it)\n    nodesPerValueArrs.sort((a, b) => b.length - a.length)\n\n    // All elements of nodesPerValueArrs should be sorted by counter and deduped\n    // So if there's only one bucket in this list the next loop is skipped\n\n    while (nodesPerValueArrs.length > 1) {\n      // TS limitation: cannot guard against .pop(), so we must double cast\n      const a = (nodesPerValueArrs.pop() as unknown) as Array<IGatsbyNode>\n      const b = (nodesPerValueArrs.pop() as unknown) as Array<IGatsbyNode>\n      nodesPerValueArrs.push(intersectNodesByCounter(a, b))\n    }\n\n    const result = nodesPerValueArrs[0]\n\n    if (result.length === 0) {\n      // Intersection came up empty. Not one node appeared in every bucket.\n      return null\n    }\n\n    return result\n  }\n}\n\n/**\n * If this returns undefined it means at least one cache was not found\n */\nfunction getBucketsForFilters(\n  filters: Array<DbQuery>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache\n): Array<Array<IGatsbyNode>> | undefined {\n  const nodesPerValueArrs: Array<Array<IGatsbyNode>> = []\n\n  // Fail fast while trying to create and get the value-cache for each path\n  const every = filters.every(filter => {\n    const filterCacheKey = createFilterCacheKey(nodeTypeNames, filter)\n    if (filter.type === `query`) {\n      // (Let TS warn us if a new query type gets added)\n      const q: IDbQueryQuery = filter\n      return getBucketsForQueryFilter(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueArrs\n      )\n    } else {\n      // (Let TS warn us if a new query type gets added)\n      const q: IDbQueryElemMatch = filter\n      return collectBucketForElemMatch(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueArrs\n      )\n    }\n  })\n\n  if (every) {\n    return nodesPerValueArrs\n  }\n\n  // \"failed at least one\"\n  return undefined\n}\n\n/**\n * Fetch all buckets for given query filter. That means it's not elemMatch.\n * Returns `false` if it found none.\n */\nfunction getBucketsForQueryFilter(\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryQuery,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  nodesPerValueArrs: Array<Array<IGatsbyNode>>\n): boolean {\n  const {\n    path: filterPath,\n    query: { comparator, value: filterValue },\n  } = filter\n\n  if (!filtersCache.has(filterCacheKey)) {\n    ensureIndexByQuery(\n      comparator as FilterOp,\n      filterCacheKey,\n      filterPath,\n      nodeTypeNames,\n      filtersCache\n    )\n  }\n\n  const nodesPerValue = getNodesFromCacheByValue(\n    filterCacheKey,\n    filterValue as FilterValueNullable,\n    filtersCache,\n    false\n  )\n\n  if (!nodesPerValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty arr because the indexing\n  // mechanism does not create an array unless there's a IGatsbyNode for it\n  nodesPerValueArrs.push(nodesPerValue)\n\n  return true\n}\n\n/**\n * Matching node arrs are put in given array by reference\n */\nfunction collectBucketForElemMatch(\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryElemMatch,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  nodesPerValueArrs: Array<Array<IGatsbyNode>>\n): boolean {\n  // Get comparator and target value for this elemMatch\n  let comparator: FilterOp = `$eq` // (Must be overridden but TS requires init)\n  let targetValue: FilterValueNullable = null\n  let f: DbQuery = filter\n  while (f) {\n    if (f.type === `elemMatch`) {\n      const q: IDbQueryElemMatch = f\n      f = q.nestedQuery\n    } else {\n      const q: IDbQueryQuery = f\n      comparator = q.query.comparator as FilterOp\n      targetValue = q.query.value as FilterValueNullable\n      break\n    }\n  }\n\n  if (!filtersCache.has(filterCacheKey)) {\n    ensureIndexByElemMatch(\n      comparator,\n      filterCacheKey,\n      filter,\n      nodeTypeNames,\n      filtersCache\n    )\n  }\n\n  const nodesByValue = getNodesFromCacheByValue(\n    filterCacheKey,\n    targetValue,\n    filtersCache,\n    true\n  )\n\n  if (!nodesByValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty arr because the indexing\n  // mechanism does not create an array unless there's a IGatsbyNode for it\n  nodesPerValueArrs.push(nodesByValue)\n\n  return true\n}\n\n/**\n * Filters and sorts a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter/sort as an object\n * @property {boolean} args.firstOnly true if you want to return only the first\n *   result found. This will return a collection of size 1. Not a single element\n * @property {{filter?: Object, sort?: Object} | undefined} args.queryArgs\n * @property {FiltersCache} args.filtersCache A cache of indexes where you can\n *   look up Nodes grouped by a FilterCacheKey, which yields a Map which holds\n *   an arr of Nodes for the value that the filter is trying to query against.\n *   This object lives in query/query-runner.js and is passed down runQuery.\n * @returns Collection of results. Collection will be limited to 1\n *   if `firstOnly` is true\n */\nexport function runFastFiltersAndSort(\n  args: IRunFilterArg\n): Array<IGatsbyNode> | null {\n  const {\n    queryArgs: { filter, sort } = {},\n    resolvedFields = {},\n    firstOnly = false,\n    nodeTypeNames,\n    filtersCache,\n    stats,\n  } = args\n\n  const result = convertAndApplyFastFilters(\n    filter,\n    firstOnly,\n    nodeTypeNames,\n    filtersCache,\n    resolvedFields,\n    stats\n  )\n\n  return sortNodes(result, sort, resolvedFields, stats)\n}\n\n/**\n * Return a collection of results. Collection will be limited to 1 if `firstOnly` is true\n */\nfunction convertAndApplyFastFilters(\n  filterFields: Array<IInputQuery> | undefined,\n  firstOnly: boolean,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  resolvedFields: Record<string, any>,\n  stats: IGraphQLRunnerStats\n): Array<IGatsbyNode> | null {\n  const filters = filterFields\n    ? prefixResolvedFields(\n        createDbQueriesFromObject(prepareQueryArgs(filterFields)),\n        resolvedFields\n      )\n    : []\n\n  if (stats) {\n    filters.forEach(filter => {\n      const filterStats = filterToStats(filter)\n      const comparatorPath = filterStats.comparatorPath.join(`.`)\n      stats.comparatorsUsed.set(\n        comparatorPath,\n        (stats.comparatorsUsed.get(comparatorPath) || 0) + 1\n      )\n      stats.uniqueFilterPaths.add(filterStats.filterPath.join(`.`))\n    })\n    if (filters.length > 1) {\n      stats.totalNonSingleFilters++\n    }\n  }\n\n  if (filters.length === 0) {\n    const filterCacheKey = createFilterCacheKey(nodeTypeNames, null)\n    if (!filtersCache.has(filterCacheKey)) {\n      ensureEmptyFilterCache(filterCacheKey, nodeTypeNames, filtersCache)\n    }\n\n    // If there's a filter, there (now) must be an entry for this cache key\n    const filterCache = filtersCache.get(filterCacheKey) as IFilterCache\n    // If there is no filter then the ensureCache step will populate this:\n    const cache = filterCache.meta.orderedByCounter as Array<IGatsbyNode>\n\n    if (firstOnly || cache.length) {\n      return cache.slice(0)\n    }\n\n    return null\n  }\n\n  const result = applyFastFilters(filters, nodeTypeNames, filtersCache)\n\n  if (result) {\n    if (stats) {\n      stats.totalIndexHits++\n    }\n    if (firstOnly) {\n      return result.slice(0, 1)\n    }\n    return result\n  }\n\n  if (stats) {\n    // to mean, \"empty results\"\n    stats.totalSiftHits++\n  }\n\n  if (firstOnly) {\n    return []\n  }\n  return null\n}\n\nfunction filterToStats(\n  filter: DbQuery,\n  filterPath: Array<string> = [],\n  comparatorPath: Array<string> = []\n): {\n  filterPath: Array<string>\n  comparatorPath: Array<string>\n} {\n  if (filter.type === `elemMatch`) {\n    return filterToStats(\n      filter.nestedQuery,\n      filterPath.concat(filter.path),\n      comparatorPath.concat([`elemMatch`])\n    )\n  } else {\n    return {\n      filterPath: filterPath.concat(filter.path),\n      comparatorPath: comparatorPath.concat(filter.query.comparator),\n    }\n  }\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n * Returns same reference as input, sorted inline\n */\nfunction sortNodes(\n  nodes: Array<IGatsbyNode> | null,\n  sort:\n    | { fields: Array<string>; order: Array<boolean | \"asc\" | \"desc\"> }\n    | undefined,\n  resolvedFields: any,\n  stats: IGraphQLRunnerStats\n): Array<IGatsbyNode> | null {\n  if (!sort || !nodes || nodes.length === 0) {\n    return nodes\n  }\n\n  // create functions that return the item to compare on\n  const dottedFields = objectToDottedField(resolvedFields)\n  const dottedFieldKeys = Object.keys(dottedFields)\n  const sortFields = sort.fields.map(field => {\n    if (\n      dottedFields[field] ||\n      dottedFieldKeys.some(key => field.startsWith(key))\n    ) {\n      return `__gatsby_resolved.${field}`\n    } else {\n      return field\n    }\n  })\n  const sortFns = sortFields.map(field => (v): ((any) => any) =>\n    getValueAt(v, field)\n  )\n  const sortOrder = sort.order.map(order =>\n    typeof order === `boolean` ? order : order.toLowerCase()\n  ) as Array<boolean | \"asc\" | \"desc\">\n\n  if (stats) {\n    sortFields.forEach(sortField => {\n      stats.uniqueSorts.add(sortField)\n    })\n  }\n\n  return _.orderBy(nodes, sortFns, sortOrder)\n}\n"],"file":"run-fast-filters.js"}